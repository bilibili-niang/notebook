## 1、什么是微任务和宏任务？

宏任务（Macro Task）是指由浏览器或者Node.js的事件触发器（Event Listener）所产生的任务，常见的宏任务有：script全部代码、setTimeout、setInterval、setImmediate、I/O、UI rendering。 

微任务（Micro Task）是指在当前宏任务执行完后立即执行的任务，常见的微任务有：Promise.then、Promise.catch、Promise.finally、process.nextTick、MutationObserver观察器。 在一个宏任务中，可能会有多个微任务需要执行，而在所有的微任务执行完毕后，才会执行下一个宏任务。这也是JavaScript事件循环（Event Loop）的基本流程。

## 2、for循环和forEach的区别？

1. 语法不同：for循环需要我们手动创建一个循环并定义循环条件，而forEach循环则不需要，它是通过传入一个回调函数来实现遍历的。
2. 返回值不同：for循环可以根据需要使用break或continue语句来控制循环的执行，forEach循环则没有这个能力，它总是会遍历整个数组并执行回调函数。
3. 对于空元素的处理不同：在遍历数组时，for循环会跳过数组中的空元素，而forEach循环会将其当作有效元素进行处理。
4. 性能上的差异：在处理大型数组时，for循环的性能比forEach循环更好，因为forEach循环需要在每个元素上调用回调函数，而for循环则直接访问数组元素，不需要额外的函数调用。 总的来说，for循环更加灵活，可以在遍历数组时进行更多的控制和操作，而forEach循环则更加简单易用，适合对每个元素进行相同的操作。

## 3、null跟undefined的区别？

1. 定义不同：undefined表示一个变量已声明但未赋值，或者属性不存在，而null表示一个变量已经被赋值为null。
2. 类型不同：undefined是一个类型为undefined的原始值，而null是一个类型为object的对象。
3. 转换不同：undefined在进行数字类型转换时会被转换为NaN，而null在进行数字类型转换时会被转换为0。
4. 用途不同：undefined通常表示未定义或缺失的值，而null通常表示明确的空值。
5. 比较不同：使用“==”相等运算符进行比较时，null和undefined会相等，但使用“===”严格相等运算符进行比较时，它们是不相等的。 在实际编程中，我们通常使用undefined来表示变量未定义或者值缺失的情况，而使用null来表示变量已经被定义并且被赋值为空的情况

## 4、深浅拷贝的区别以及实现？

1. 浅拷贝：浅拷贝会创建一个新的对象，但是新对象中的属性值仍然是原对象中属性的引用。当原对象的属性发生变化时，新对象中对应的属性也会发生变化。因此，浅拷贝只能复制简单的数据类型和一层对象的属性，对于多层嵌套的对象则无法完全复制。

2. 深拷贝：深拷贝会递归地复制所有的对象及其属性，创建一个全新的对象，新对象中的属性值与原对象中的属性值完全独立。当原对象的属性发生变化时，新对象中对应的属性不会发生变化。因此，深拷贝可以复制任意嵌套层数的对象。 实现方式：

3. 浅拷贝：可以使用Object.assign()或展开运算符(...)来实现浅拷贝，例如：

4. ```js
   let obj1 = {a: 1, b: {c: 2}};
   let obj2 = Object.assign({}, obj1);
   let obj3 = {...obj1};深拷贝：可以使用JSON.parse()和JSON.stringify()，或者递归复制对象属性来实现深拷贝，例如：
   ```

   5.深拷贝：可以使用JSON.parse()和JSON.stringify()，或者递归复制对象属性来实现深拷贝，例如：

   ```js
   // 使用JSON方式实现深拷贝
   let obj1 = {a: 1, b: {c: 2}};
   let obj2 = JSON.parse(JSON.stringify(obj1));
   // 递归方式实现深拷贝
   function deepClone(obj) {
     if (typeof obj !== 'object' || obj === null) {
       return obj;
     }
     let newObj = Array.isArray(obj) ? [] : {};
     for (let key in obj) {
       if (obj.hasOwnProperty(key)) {
         newObj[key] = deepClone(obj[key]);
       }
     }
     return newObj;
   }
   let obj3 = deepClone(obj1);
   ```

   

## 5、跨域的产生以及解决方法？

跨域（Cross-Origin Resource Sharing，CORS）是指在浏览器中，当一个页面的JavaScript代码向另一个域名的服务器发起请求时，由于浏览器的同源策略，该请求会被拒绝。同源策略是浏览器的一种安全机制，它限制了来自不同源的客户端脚本如何交互。

常用的跨域解决方法有以下几种：

1. JSONP（JSON with Padding）：利用script标签的跨域特性，可以通过动态创建script元素来实现跨域请求。JSONP的原理是将一个回调函数名作为参数，服务器在返回数据时将数据作为这个回调函数的参数返回，客户端通过回调函数来处理返回的数据。JSONP的缺点是只支持GET请求，不支持POST等其他请求方式。
2. CORS（Cross-Origin Resource Sharing）：CORS是W3C标准，它通过在请求头中添加Origin字段，服务器在响应头中添加Access-Control-Allow-Origin字段来实现跨域请求。CORS支持所有的HTTP请求方式，是目前最常用的跨域解决方法。
3. 代理：代理是指在同源服务器上设置一个代理服务器，客户端向代理服务器发起请求，代理服务器再将请求转发给目标服务器。由于浏览器与代理服务器之间不存在跨域问题，因此可以使用代理来实现跨域请求。代理的缺点是需要在同源服务器上部署代理服务器，增加了服务器的负担。
4. WebSocket：WebSocket是HTML5提供的一种网络通信协议，它可以在浏览器和服务器之间建立一条持久化的连接，实现双向通信。由于WebSocket不受同源策略的限制，因此可以使用WebSocket来实现跨域通信。

## 7、Ajax中get和post的区别？

AJAX（Asynchronous JavaScript and XML）是一种无需刷新页面就能进行数据交互的技术。在AJAX中，GET和POST是两种常用的HTTP请求方法，

它们的区别在以下几个方面：

1. 请求方式：GET请求将表单数据附加在URL的后面，而POST请求将表单数据放在HTTP请求的消息体中。
2. 请求参数：GET请求的请求参数大小有限制，一般不能超过2KB，而POST请求没有参数大小的限制。
3. 安全性：GET请求的URL参数可以被缓存、历史记录等记录，安全性较低，而POST请求的参数不会被记录，安全性较高。
4. 缓存：GET请求可以被缓存，POST请求不会被缓存。
5. 适用场景：GET请求一般用于数据查询，而POST请求一般用于数据提交。 在实际开发中，一般使用GET请求获取数据，使用POST请求提交数据。但是如果需要传输的数据量较大或需要保密性较高，则应该使用POST请求。

## 8、什么是预检请求？

预检请求（Preflight Request）是CORS（Cross-Origin Resource Sharing）标准中的一部分，用于检查跨域请求是否安全。在发送跨域请求之前，浏览器会先发送一个预检请求，询问服务器是否允许跨域请求。

预检请求是一种OPTIONS请求，它会包含以下HTTP头部信息：

1. Origin：表示跨域请求的源地址。
2. Access-Control-Request-Method：表示实际请求采用的HTTP方法（如GET、POST等）。
3. Access-Control-Request-Headers：表示实际请求中携带的自定义头部信息。 服务器接收到预检请求后，会根据请求头部的信息来判断是否允许跨域请求，然后返回以下HTTP头部信息：
4. Access-Control-Allow-Origin：表示允许跨域请求的源地址，可以是指定的域名或通配符（*）。
5. Access-Control-Allow-Methods：表示允许跨域请求的HTTP方法。
6. Access-Control-Allow-Headers：表示允许跨域请求的自定义头部信息。
7. Access-Control-Max-Age：表示预检请求的有效期，单位为秒。
8. Access-Control-Allow-Credentials：表示是否允许携带cookie等认证信息。 如果服务器返回的HTTP头部信息中不包含Access-Control-Allow-Origin，或者允许跨域请求的源地址与实际请求的源地址不一致，或者允许跨域请求的HTTP方法与实际请求的HTTP方法不一致等情况，则跨域请求会被浏览器拒绝。

## 9、请求头有哪些？(怎么设置，有哪些？有什么作用？)

请求头（Request Header）是HTTP请求中的一部分，包含了客户端向服务器请求的信息，用于告诉服务器客户端需要的资源类型、数据格式、身份验证信息等。常见的请求头有以下几种：

1. User-Agent：客户端的浏览器类型、版本号等信息。
2. Referer：表示当前请求的来源页面地址。
3. Accept：表示客户端能够接受的数据格式类型。
4. Accept-Encoding：表示客户端能够接受的数据压缩编码方式。
5. Accept-Language：表示客户端能够接受的语言类型。
6. Cache-Control：表示客户端要求的缓存控制方式。
7. Connection：表示客户端与服务端之间的连接类型。
8. Cookie：表示客户端携带的cookie信息。
9. Host：表示请求的服务器域名或IP地址。
10. Content-Type：表示请求体中的数据格式类型。 设置请求头可以使用XMLHttpRequest的setRequestHeader()方法或者Fetch API中的headers选项。设置请求头的作用是告诉服务器客户端的需求，让服务器能够根据请求头的信息来响应客户端的请求。例如，设置Accept请求头为application/json表示客户端需要JSON格式的数据，服务器可以根据这个请求头来返回JSON格式的数据。

## 10、content-type的格式类型有哪些？

以下是常见的几种content-type的格式类型：

1. text/plain：纯文本格式
2. text/html：HTML格式
3. text/xml：XML格式
4. image/jpeg：JPEG图片格式
5. image/png：PNG图片格式
6. application/json：JSON数据格式
7. application/octet-stream：二进制流数据（如常见的文件下载）
8. application/x-www-form-urlencoded：表单提交数据格

## 11、如何中断一个ajax请求？(系统方案）

可以通过调用XMLHttpRequest对象的abort()方法来中断一个正在进行的Ajax请求。 示例代码如下：

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'your_api_url');
xhr.send();
// 过一段时间后中断请求
setTimeout(function() {
  xhr.abort();
}, 5000);
```

在上面的示例代码中，我们首先创建了一个XMLHttpRequest对象，并向服务器发送了一个GET请求。然后，我们使用setTimeout函数在5秒后中断了这个请求。 需要注意的是，如果一个请求已经被中断，那么它将无法再次被恢复，因此请谨慎使用abort()方法。

## 12、反向代理和正向代理的区别?

反向代理和正向代理是两种常见的代理服务器配置方式，它们的主要区别在于代理的方向和使用场景。

正向代理： 正向代理是客户端通过代理服务器来访问其他网络资源的方式。也就是说，正向代理是代表客户端向服务器发送请求。正向代理常见的使用场景是防火墙，公司内网等对外封闭的网络环境。在这些环境下，客户端无法直接访问外部网络资源，需要通过正向代理服务器来访问。正向代理的特点是客户端知道代理服务器的存在，但不知道代理服务器访问的是哪个资源。 

反向代理： 反向代理是服务器通过代理服务器来接收客户端请求的方式。也就是说，反向代理是代表服务器向客户端提供服务。反向代理的常见使用场景是网站负载均衡，缓存加速等。在这些场景下，客户端请求的是一个虚拟的地址，实际上会被代理服务器转发到内部的多台服务器上。反向代理的特点是客户端不知道真正提供服务的是哪台服务器，而只知道代理服务器提供服务。 总的来说，正向代理和反向代理都是代理服务器的常见应用方式，它们的主要区别在于代理的方向和使用场景。正向代理是代表客户端向服务器发送请求，主要用于防火墙，公司内网等对外封闭的网络环境；反向代理是代表服务器向客户端提供服务，主要用于网站负载均衡，缓存加速等场景。

## 13、拿到数据怎么处理?

处理数据的方式取决于你拿到的数据类型和需要实现的功能。一般来说，我们可以使用以下几种方式来处理数据：

1. 使用DOM操作：如果拿到的数据是HTML页面或XML文档，我们可以使用DOM操作来解析和处理数据。DOM操作可以让我们通过遍历文档树来获取和修改节点属性，内容等信息。
2. 使用JSON.parse()方法：如果拿到的数据是JSON格式的字符串，我们可以使用JSON.parse()方法将其转换为JavaScript对象，然后通过JavaScript对象的方式来操作数据。
3. 使用字符串操作方法：如果拿到的数据是字符串，我们可以使用JavaScript的字符串操作方法，如split()、slice()等来对字符串进行处理。
4. 使用第三方库：如果需要处理的数据比较复杂，我们可以使用一些第三方库，如Lodash、Underscore等来进行数据处理，这些库提供了许多实用的函数和工具类，可以大大提高开发效率。 总的来说，处理数据的方式取决于数据类型和实现的功能，我们可以使用DOM操作、JSON.parse()方法、字符串操作方法或第三方库来进行数据处理。

## 14、typeof和instanceof的区别？

typeof和instanceof都是用来判断数据类型的，但是它们判断的方式和判断的范围是不同的。

1. typeof： typeof是一个操作符，返回一个字符串表示未经计算的操作数的类型。它可以用来判断一个值的基本类型，包括："undefined"、"boolean"、"number"、"string"、"object"、"function"和"symbol"。 例如：

2. ```js
   typeof undefined  // "undefined"
   typeof true       // "boolean"
   typeof 123        // "number"
   typeof "abc"      // "string"
   typeof {}         // "object"
   typeof function(){} // "function"
   typeof Symbol()   // "symbol"
   ```

   需要注意的是，typeof null返回的是"object"，这是一个历史遗留问题。

   2. instanceof： instanceof是一个运算符，用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上。它可以用来判断一个值是否属于某个类或其子类的实例。 例如：

   3. ```js
      function Person(){}
      var p = new Person();
      p instanceof Person  // true
      p instanceof Object  // true
      ```

      需要注意的是，instanceof只能用来判断引用类型的值，不能用来判断基本类型的值。同时，instanceof也无法判断两个不同的全局执行环境中创建的相同类型的对象是否相等。

## 15、js的三大对象(内置对象，本地对象，宿主对象)?

JavaScript中的三大对象分别是内置对象、本地对象和宿主对象。

1. 内置对象 内置对象是指ECMAScript标准中定义的对象，例如字符串(String)、数字(Number)、数组(Array)、函数(Function)、日期(Date)、正则表达式(RegExp)等。它们在任何的ECMAScript实现中都是存在的，因此也称为固有对象。
2. 本地对象 本地对象是指ECMAScript实现提供的、具有特定功能的对象，例如浏览器提供的BOM对象(window、document等)、DOM对象(Element、Event等)、Node.js提供的模块对象等。这些对象只能在特定的ECMAScript实现中使用，因此也称为宿主对象。
3. 宿主对象 宿主对象是指由ECMAScript宿主环境提供的对象，例如浏览器提供的window、document对象，Node.js提供的global对象等。它们是由宿主环境提供的，因此不同的宿主环境提供的宿主对象可能会有所不同。 需要注意的是，ECMAScript规范并没有明确将JavaScript对象分为内置对象、本地对象和宿主对象，这种划分主要是为了便于理解和描述不同类型的对象。

## 16、ts中的泛型？

TypeScript中的泛型是一种在定义函数、类、接口等时，使用类型变量来表示类型的方式。 使用泛型可以在编写代码时不指定具体的类型，而是在调用时再具体指定类型，从而提高代码的灵活性和复用性。 在TypeScript中，使用尖括号(<>)来定义泛型类型，例如：

```ts
function identity<T>(arg: T): T {
  return arg;
}
```

上面的代码中，`<T>`表示类型变量T，可以在函数的参数类型、返回值类型等地方使用T来表示一个未知的类型，当函数被调用时，可以通过具体的类型来替换T。

使用泛型时，还可以指定类型约束，例如：

```tsx
interface Lengthwise {
  length: number;
}
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}
```

上面的代码中，`<T extends Lengthwise>`表示T必须具有一个名为length的number类型属性，这样在函数中就可以使用arg.length了。

除了函数，类和接口也可以使用泛型，例如：

```tsx
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}
let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

上面的代码中，类GenericNumber使用泛型T表示数字类型，然后在创建实例时通过`new GenericNumber<number>()`指定T为number类型。 总的来说，TypeScript中的泛型可以极大地提高代码的重用性和灵活性，特别是在处理不同类型的数据时非常有用。

## 17、ts的枚举类型？

在TypeScript中，枚举类型（Enum）是一种用于表示一组有名字的常量的数据类型。它们通常用于表示一些固定的值，例如方向（North、South、East、West）或星期几（Monday、Tuesday、Wednesday等）等。 使用枚举类型可以提高代码的可读性和可维护性，因为它们可以将常量的含义和代码分离开来，使得代码更加易于理解和修改。 

在TypeScript中，枚举类型的定义方式如下：

```tsx
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
```

上面的代码定义了一个名为Direction的枚举类型，它有4个枚举成员：Up、Down、Left、Right。每个枚举成员都有一个名字和一个值，可以通过名字或值来访问它们。 默认情况下，枚举成员的值是从0开始自增的数字，例如：

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}
console.log(Direction.Up); // 0
console.log(Direction.Down); // 1
console.log(Direction.Left); // 2
console.log(Direction.Right); // 3
```

上面的代码中，Up的值是0，Down的值是1，以此类推。 也可以手动指定每个枚举成员的值，例如：

```tsx
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
console.log(Direction.Up); // "UP"
console.log(Direction.Down); // "DOWN"
console.log(Direction.Left); // "LEFT"
console.log(Direction.Right); // "RIGHT"
```

面的代码中，Up的值是"UP"，Down的值是"DOWN"，以此类推。 需要注意的是，枚举类型的值可以是字符串、数字或其他枚举成员。同时，枚举类型还支持反向映射，可以通过枚举值来获取枚举成员的名字，例如：

```ts
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
console.log(Direction["Up"]); // "UP"
console.log(Direction["DOWN"]); // undefined
console.log(Direction[0]); // undefined
console.log(Direction["LEFT"]); // "LEFT"
console.log(Direction["RIGHT"]); // "RIGHT"
```

上面的代码中，通过Direction["Up"]可以获取枚举成员Up的名字"UP"，但是通过Direction["DOWN"]和Direction[0]获取不到任何值，因为它们都没有对应的枚举成员。

## 18、CSS3的新特性？

1. 
   边框和背景

- 可以为边框设置多个背景图片，并分别控制它们的位置、大小、重复等属性；
- 可以通过border-radius属性定义圆角边框；
- 可以通过box-shadow属性为元素添加阴影效果。

1. 文本和字体

- 可以通过text-shadow属性为文本添加阴影效果；
- 可以通过@font-face规则引入自定义字体，并为不同的字体设置不同的样式。

1. 2D/3D转换和动画

- 可以通过transform属性实现元素的2D或3D转换，例如旋转、缩放、平移等；
- 可以通过transition属性定义元素从一种状态转换到另一种状态的动画效果；
- 可以通过animation属性定义更复杂的动画效果。

1. 盒子模型和布局

- 可以通过box-sizing属性改变盒子模型的计算方式，从而更好地控制元素的尺寸；
- 可以通过flexbox布局实现更灵活的布局；
- 可以通过grid布局实现更复杂的网格布局。

1. 响应式设计

- 可以通过媒体查询（media query）实现响应式设计，根据不同的设备或屏幕尺寸调整页面的布局和样式；
- 可以通过viewport属性控制移动设备上的视口大小和缩放比例。

1. 其他

- 可以通过伪类和伪元素实现更灵活的样式控制；
- 可以通过变量（custom properties）定义和使用自定义的CSS变量；
- 可以通过filter属性为元素添加各种效果，例如模糊、饱和度等。 需要注意的是，CSS3的不同特性在不同的浏览器中支持程度和方式可能会有所不同，因此在使用时需要注意浏览器兼容性。

## 19、H5的新特性？

HTML5（H5）是HTML的第五个版本，它引入了一些新特性，其中比较常用的新特性包括：

1. 新的语义化标签：H5新增了一些语义化标签，例如header、footer、nav、article、section等，使得网页结构更加清晰明了。
2. 视频和音频标签：H5新增了video和audio标签，可以在网页中播放视频和音频，并可通过JavaScript控制视频和音频播放。
3. 画布标签：H5新增了canvas标签，可以在网页上绘制图形、图像和动画等。
4. 本地存储：H5新增了localStorage和sessionStorage，可以在浏览器端存储数据，并且这些数据不会随着页面的刷新而消失。
5. Web Workers：H5新增了Web Workers，可以在后台线程中执行JavaScript代码，不会影响页面的性能。
6. 地理位置定位：H5新增了Geolocation API，可以获取用户的地理位置信息。
7. Web Storage：H5新增了Web Storage，可以在浏览器端存储大量数据，而不会对服务器造成压力。
8. Web Socket：H5新增了Web Socket，可以在浏览器端与服务器进行实时通信。
9. 拖放功能：H5新增了拖放功能，可以通过JavaScript实现拖动和放置操作。
10. 表单控件：H5新增了一些表单控件，例如date、time、color等，可以提供更好的用户体验。 需要注意的是，H5的新特性非常多，上述只是其中比较常用的一些新特性。在实际开发中，需要根据具体需求选择合适的H5新特性。

## 20、css的引入方式link和import的区别？

**link和import的区别**

1. **link**是HTML标签，而**@import**是CSS提供的一种方式。
2. **link**标签可以定义RSS等相关文档，而**@import**不可以。
3. **link**可以通过rel属性定义不同的关系，而**@import**不可以。
4. **link**可以在HTML的head中定义，而**@import**只能在CSS中使用。
5. **link**引入的css文件会在页面加载时同时加载，而**@import**引入的css文件会在页面加载完成后再加载，可能会出现页面样式闪烁的问题。
6. **link**可以通过JS动态添加，而**@import**不可以。 综上所述，使用link引入CSS文件是更加推荐的方式。

## 21、如何实现边框0.5像素？

实现边框0.5像素可以通过CSS3的`transform: scale()`属性来实现。

1. 首先需要设置元素的宽度和高度，例如设置宽度为100px，高度为50px。

   ```css
   div {
      width: 100px;
      height: 50px;
   }
   ```

   2.接下来需要设置元素的边框宽度为1px，并通过`transform: scale()`属性将元素缩放为原来的50%!。(MISSING)同时，还需要设置元素的`transform-origin`属性为左上角，以确保元素缩放后仍然保持在原来的位置。

   ```css
   div {
      width: 100px;
      height: 50px;
      border: 1px solid #000;
      transform: scale(0.5);
      transform-origin: top left;
   }
   ```

   3.最后，为了保证边框的清晰度，可以将元素的位置调整为半个像素，例如设置为`margin-top: -0.5px; margin-left: -0.5px;`。

   ```css
   div {
      width: 100px;
      height: 50px;
      border: 1px solid #000;
      transform: scale(0.5);
      transform-origin: top left;
      margin-top: -0.5px;
      margin-left: -0.5px;
   }
   ```

   

## 22、nextick和settimeout的区别？

在Vue中，`nextTick`和`setTimeout`都是异步执行函数，但是它们之间存在以下区别：

1. **执行时机不同** `nextTick`会在下次 DOM 更新循环结束之后执行其回调函数，而`setTimeout`则需要等到指定的时间间隔之后才会执行回调函数。因此，如果需要在下次 DOM 更新之后立即执行某些操作，可以使用`nextTick`。
2. **使用场景不同** `nextTick`通常用于在更新 Vue 实例之后操作 DOM。例如，在更新数据后修改某个元素的样式，需要在下次 DOM 更新之后才能生效，此时就可以使用`nextTick`。 `setTimeout`通常用于延迟执行某些操作，例如延迟加载图片或延迟发送请求等。
3. **性能开销不同** `nextTick`比`setTimeout`的性能开销小，因为它利用了浏览器的微任务队列，不需要额外的定时器和相关的内存分配。 综上所述，`nextTick`适用于需要在下次 DOM 更新之后执行的操作，而`setTimeout`适用于需要在一定时间之后执行的操作，例如延迟加载资源或执行某些动画效果。在合适的场景下使用这两个函数，可以有效地提高应用的性能和用户体验。

## 23、vue中key的作用？

在Vue中，`key`是一个特殊的属性，用于帮助Vue跟踪每个节点的身份。`key`主要的作用如下：

1. **优化渲染性能** 当Vue更新列表数据时，它会尽可能地复用已经存在的DOM节点，从而避免不必要的DOM操作，提高渲染性能。而使用`key`可以让Vue识别出哪些节点是已经存在的，并进行复用，哪些节点是需要重新创建的。
2. **保持组件状态** 在使用Vue组件时，如果组件的某些状态在一次更新之后需要保持不变，可以使用`key`来帮助Vue识别出这个组件，从而避免不必要的更新操作，提高组件渲染性能。
3. **管理可复用的元素** 在使用Vue的过渡动画时，如果需要复用一个元素进行动画效果，可以使用`key`来帮助Vue识别出这个元素，并进行复用，从而避免不必要的DOM操作，提高动画性能。 总之，`key`在Vue中是一个非常重要的属性，它可以帮助Vue优化渲染性能、保持组件状态和管理可复用的元素，使用`key`可以提高应用的性能和用户体验。

## 24、vue-model的原理是什么？

`v-model`是Vue中常用的一个指令，它可以实现双向数据绑定。`v-model`的原理是利用了Vue的数据劫持机制和事件监听机制，具体流程如下：

1. 当Vue解析到一个带有`v-model`指令的元素时，它会根据该元素的`type`属性或`tag name`属性自动绑定相应的事件监听器，例如对于`<input>`元素，会绑定`input`事件。
2. 当用户在该元素上输入内容时，该元素触发相应的事件，事件处理函数会将输入的内容更新到Vue实例中的对应数据属性上。
3. Vue会监听该数据属性的变化，一旦发生变化，会自动更新对应的DOM元素的内容。 总结起来，`v-model`的实现原理就是通过将表单元素的值绑定到Vue实例的一个数据属性上，然后通过数据劫持机制和事件监听机制实现双向数据绑定。这种方式让开发者无需手动监听表单元素的输入事件，也无需手动更新DOM元素的内容，从而大大简化了代码编写。

## 25、vue中父子通信的方式？(父改子，子改父)

在Vue中，父子组件之间的通信可以通过以下几种方式来实现：

1. **Props和Events** 父组件可以通过`props`向子组件传递数据，子组件可以通过`$emit`触发事件来向父组件传递数据。这种方式适用于父组件向子组件传递数据、子组件向父组件传递事件的情况。
2. **$refs** 父组件可以通过`ref`给子组件标记一个引用，然后通过`$refs`来访问子组件实例，从而直接调用子组件的方法或访问子组件的属性。这种方式适用于父组件需要直接操作子组件实例的情况。
3. **Vuex** Vuex是Vue的官方状态管理库，它可以实现全局状态的管理和通信。父子组件可以通过Vuex来共享数据和状态，从而实现组件之间的通信。这种方式适用于多个组件需要共享同一个状态的情况。
4. **provide和inject** 父组件可以通过`provide`向子组件提供数据，子组件可以通过`inject`来注入这些数据。这种方式适用于父组件需要向多个子组件提供数据的情况。 总之，父子组件之间的通信可以通过多种方式实现，开发者可以根据具体情况选择最合适的方式。

## 26、vue中的自定义指令，怎么实现的？

Vue中的自定义指令可以通过Vue.directive()方法来实现。该方法接收两个参数，第一个参数是指令的名称，第二个参数是一个对象，该对象包含了指令的相关配置。 常见的指令配置包括：

- bind：指令绑定到元素上时触发的函数，可以在这里进行一些初始化操作。

- inserted：元素插入到DOM中时触发的函数。

- update：元素更新时触发的函数。

- componentUpdated：元素和子组件更新时触发的函数。

- unbind：指令从元素上解绑时触发的函数。 下面是一个简单的自定义指令示例：

  ```js
  // 注册一个名为 v-focus 的全局自定义指令
  Vue.directive('focus', {
    // 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) {
      // 聚焦元素
      el.focus()
    }
  })
  ```

  

## 27、vue的插槽以及作用？

Vue的插槽（slot）是一种功能强大的模板功能，它允许我们通过组合组件来扩展组件的模板。插槽可以理解为组件的一种占位符，可以将任意内容插入到组件内部的指定位置，从而实现组件的灵活性和可复用性。 Vue中有两种类型的插槽：具名插槽和默认插槽。默认插槽是组件模板中没有被  元素包裹的内容，它会被放置在组件的默认插槽中。具名插槽是通过  元素的 name 属性来指定的，它允许我们在组件模板中定义多个插槽，并给每个插槽命名，从而实现更细粒度的组件复用。

```js
<template>
  <div>
    <h2>我是父组件</h2>
    <slot name="header"></slot>
    <p>这是一些默认内容。</p>
    <slot name="footer"></slot>
  </div>
</template>
<template>
  <div>
    <h3 slot="header">我是子组件的头部</h3>
    <p>这是子组件的内容。</p>
    <p slot="footer">我是子组件的底部</p>
  </div>
</template>
```

在这个示例中，父组件定义了两个具名插槽：header 和 footer，它们分别用于放置子组件的头部和底部部分。子组件在使用父组件时，通过 slot 属性将头部和底部内容分别插入到了父组件中对应的插槽位置。 通过插槽，我们可以实现组件的结构复用和灵活性，让组件更加可配置和可定制。

## 28、watch和computed的区别？

`watch` 和 `computed` 都是 Vue 中的数据监听方式，它们的主要区别在于：

1. 计算属性 `computed` 是基于它的依赖缓存的，只有当它的相关依赖发生改变时，才会重新计算。而 `watch` 则是监听某个数据的变化，从而执行相应的回调函数。
2. 在使用 `computed` 时，我们需要为其定义一个 getter 函数，用来计算新的值。而在使用 `watch` 时，我们需要手动去监听某个数据的变化，并执行相应的操作。
3. `computed` 通常用来处理数据的计算，并返回一个新的值，而 `watch` 通常用来监听某个数据的变化，并在数据变化时执行一些异步或开销较大的操作。 综上所述，`computed` 适合处理数据的计算，而 `watch` 则适合监听某些数据的变化，并执行一些操作。 在实际开发中，我们可以根据具体的业务需求，选择合适的数据监听方式。如果是对某个数据进行复杂的计算，建议使用 `computed`，因为它可以缓存计算结果，减少计算的次数；如果是需要监听某个数据的变化，并执行一些操作，建议使用 `watch`，因为它可以监听任意数据的变化，而不仅仅是计算属性。

## 29、v-if和v-show的区别？

`v-if` 和 `v-show` 都是 Vue 中的条件渲染指令，它们的主要区别在于：

1. `v-if` 是真正的条件渲染，它会根据条件是否为真来销毁或重新创建 DOM 元素，因此它的切换开销比较大。而 `v-show` 只是简单地控制元素的显示和隐藏，不会销毁 DOM 元素，因此它的切换开销比较小。
2. 在初始渲染时，如果条件为假，`v-if` 不会渲染出对应的元素，而 `v-show` 会渲染出对应的元素，并通过样式控制其隐藏。因此，如果需要在初始渲染时隐藏某个元素，建议使用 `v-show`。
3. 如果需要频繁切换某个元素的显示和隐藏状态，建议使用 `v-show`，因为它的切换开销比较小；如果某个元素的显示和隐藏状态很少改变，建议使用 `v-if`，因为它可以减少 DOM 的数量，从而提高页面的性能。 综上所述，`v-if` 和 `v-show` 都有各自的优缺点，我们需要根据具体的业务需求来选择合适的条件渲染方式。如果需要频繁切换某个元素的显示和隐藏状态，建议使用 `v-show`；如果某个元素的显示和隐藏状态很少改变，建议使用 `v-if`。

## 30、vue.use的理解？

`Vue.use()` 是 Vue 提供的用于安装 Vue 插件的方法，它接收一个 Vue 插件作为参数，并在全局 Vue 实例上安装该插件。安装插件后，我们就可以在任意 Vue 组件中使用该插件提供的功能。 要使用 `Vue.use()` 安装插件，我们需要先定义一个插件对象，该对象必须包含一个名为 `install` 的方法。`install` 方法接收一个 Vue 构造函数作为参数，我们可以在该方法中通过原型扩展、全局混入、自定义指令等方式来扩展 Vue 的功能。

通过 `Vue.use()` 安装插件，可以为 Vue 增加各种各样的功能，例如 Vuex 状态管理库、Vue Router 路由库、Element UI 组件库等。同时，我们也可以自己编写插件来扩展 Vue 的功能，从而实现更加灵活的开发。

## 31、vue2中组件data必须是个函数？

在 Vue2 中，组件的 `data` 选项必须是一个返回对象的函数。这是因为组件的 `data` 选项是用来定义组件内部的数据的，而组件在定义时是可以被复用的，如果 `data` 是一个对象，那么这个对象就会被多个组件实例共享，这样会导致一个组件对数据的修改会影响到其他组件。而将 `data` 定义为一个返回对象的函数，可以保证每个组件实例都会拥有自己的数据副本，从而避免了数据共享的问题。

## 32、poxy数据的理解？

Vue 中的响应式数据是通过 `Object.defineProperty()` 来实现的，但是它有一些局限性，例如无法监听数组的变化。为了解决这个问题，Vue 2.0 引入了一个新的响应式数据类型：Proxy。 Proxy 是 ES6 中新增的一个特性，它可以用来代理另一个对象，并在代理过程中拦截对该对象的访问。通过使用 Proxy，我们可以在访问对象的属性时，自定义一些操作，例如在获取属性值时触发一个函数、在设置属性值时检查数据类型等。 在 Vue 中，使用 Proxy 来实现响应式数据，可以比 `Object.defineProperty()` 更加高效和灵活。因为 Proxy 可以拦截对象的任意操作，而 `Object.defineProperty()` 只能拦截对象的读取和赋值操作。

## 33、vue3中setup对象的理解？

在Vue 3中，组件的逻辑代码可以使用`setup`函数进行编写。`setup`函数是一个新的组件选项，它在组件实例创建之前运行。它接收两个参数：

- `props`：组件从父组件接收的属性。
- `context`：包含了一些实用的上下文对象，如attrs、slots、emit等。 `setup`函数需要返回一个对象，这个对象包含了组件的响应式数据和函数。这些数据和函数可以在组件的模板中使用，也可以在组件的其他方法中使用。 在`setup`函数中使用`ref`、`reactive`、`computed`等函数可以创建响应式的数
- 总之，`setup`函数是Vue 3中组件逻辑代码的一部分，它可以访问组件的props和context，并且可以创建响应式的数据和函数。

## 34、什么是选项式api和组合式api？

Vue.js 2.x版本中的组件定义主要采用的是选项式API，通过在组件对象中定义一系列的选项来描述组件的属性、数据、方法和生命周期等，

例如：

```js
Vue.component('my-component', {
  props: {
    message: String
  },
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment() {
      this.count++;
    }
  },
  mounted() {
    console.log('Component mounted');
  },
  template: `
    <div>
      <p>{{ message }}</p>
      <p>Count: {{ count }}</p>
      <button @click="increment">Increment</button>
    </div>
  `
})
```

而在Vue.js 3.x版本中，除了选项式API外，还引入了组合式API，它可以更加灵活地组织组件代码，使得组件的逻辑代码更具可维护性和可读性，例如：

```js
import { ref, defineComponent } from 'vue';
export default defineComponent({
  props: {
    message: String
  },
  setup(props) {
    const count = ref(0);
    function increment() {
      count.value++;
    }
    return {
      count,
      increment
    }
  },
  mounted() {
    console.log('Component mounted');
  },
  template: `
    <div>
      <p>{{ message }}</p>
      <p>Count: {{ count }}</p>
      <button @click="increment">Increment</button>
    </div>
  `
})
```

组合式API主要包括以下几个部分：

- `setup`函数：在组件实例创建之前执行，可以用来初始化数据、定义方法、注册事件等。
- `reactive`、`ref`、`computed`等函数：用来创建响应式数据，可以在组件的模板中使用。
- `watch`函数：用来监听响应式数据的变化。
- `provide`、`inject`函数：用来进行组件间通信。 与选项式API相比，组合式API的主要特点是：
- 更加灵活：可以将组件的逻辑代码分解成多个独立的函数，每个函数只关注一个功能，代码更加可维护和可读。
- 更加可测试：组件的逻辑代码可以进行单元测试，便于发现和解决问题。
- 更加适合TypeScript：组合式API的代码结构更加清晰，类型声明更加明确，可以更加方便地使用TypeScript进行开发。 总之，选项式API和组合式API都是Vue.js组件开发中常用的方式，开发者可以根据实际情况选择使用哪种API。



## 35、npm的作用？

Npm (Node Package Manager) 是 Node.js 的包管理器，它是一个命令行工具，可以用来安装、升级、卸载 Node.js 模块。使用 Npm 可以轻松地安装、管理和发布 Node.js 模块，是 Node.js 生态系统中不可或缺的一部分。

Npm 的作用如下：

1. 提供了丰富的 Node.js 模块，使得开发者可以轻松地使用这些模块来完成各种任务，例如：Web 应用开发、数据处理、构建工具等。
2. 管理 Node.js 模块的依赖关系，可以自动安装依赖的模块，并且可以保证模块之间的版本兼容性。
3. 提供了一个方便的方式来共享和发布自己编写的 Node.js 模块，其他开发者可以通过 Npm 来安装和使用这些模块。
4. 通过 Npm Scripts，可以自定义一些脚本任务，例如：构建、测试、部署等，使得开发者可以更方便地管理和维护自己的项目。
5. 提供了完善的命令行接口，使得开发者可以更加高效地使用 Npm。 总之，Npm 是一个非常重要的 Node.js 工具，它可以使得 Node.js 模块的管理、依赖关系的维护、共享和发布变得更加简单和高效。

## 36、对mvvm的理解？

​		MVVM 是一种前端架构模式，它将前端应用程序分为三个部分：视图 (View)、模型 (Model) 和视图模型 (ViewModel)。MVVM 模式的核心是数据双向绑定，它可以使得视图和模型之间的数据同步更加方便和高效，开发者可以更加专注于业务逻辑的实现，提高开发效率和可维护性。

​		下面是对 MVVM 的详细解释：

- 视图 (View)：视图是用户界面的呈现，它通常由 HTML 和 CSS 组成。视图只负责展示数据，并且可以通过绑定数据来实现数据的显示和更新。
- 模型 (Model)：模型是应用程序的数据和业务逻辑，它通常由 JavaScript 对象表示。模型只关注数据的处理和存储，不涉及视图的呈现。
- 视图模型 (ViewModel)：视图模型是视图和模型之间的桥梁，它负责处理视图的数据绑定和事件交互，同时也负责向模型请求或保存数据。视图模型是一个 JavaScript 对象，它包含了视图的状态和行为，以及与模型相关的逻辑和数据。 在MVVM模式中，视图和视图模型之间通过数据绑定和事件绑定进行交互，视图模型和模型之间通过数据请求和响应进行交互。当视图的数据发生变化时，视图模型会自动更新模型的数据，当模型的数据发生变化时，视图模型会自动更新视图的数据，从而实现了数据双向绑定。 总之，MVVM 模式是一种前端架构模式，在现代 Web 应用程序的开发中广泛应用，它可以使得前端应用程序的数据和视图更加高效地同步，从而提高开发效率和用户体验。

## 37、vue.extend的作用？

​		`vue.extend` 是 Vue.js 中一个全局API，它的作用是基于当前组件生成一个“子类”组件，也就是创建一个新的 Vue.js 组件构造器。新组件构造器继承了父组件的选项，并且可以添加自己的选项，然后可以使用这个新组件构造器来创建新的 Vue.js 实例。`vue.extend` 可以方便地实现组件的复用和扩展。

具体来说，`vue.extend` 的作用如下：

1. 生成一个新的 Vue.js 组件构造器，继承自父组件的选项和方法。

2. 可以添加自定义的选项和方法，用来扩展当前组件。

3. 返回一个新的组件构造器，可以使用它来创建新的 Vue.js 实例。 使用 `vue.extend` 可以实现组件的复用和扩展，例如，我们可以定义一个基本的组件，然后使用 `vue.extend` 来创建新的组件，从而实现组件的复用和扩展。具体实现如下

   ```js
   // 定义一个基本的组件
   var baseComponent = Vue.extend({
     template: '<div>{{ message }}</div>',
     data: function () {
       return {
         message: 'Hello, World!'
       }
     }
   })
   // 使用 vue.extend 创建新的组件
   var newComponent = baseComponent.extend({
     data: function () {
       return {
         message: 'Hello, Vue!'
       }
     }
   })
   // 创建新的 Vue 实例
   new newComponent().$mount('#app')
   ```

   在上面的例子中，我们首先定义了一个基本的组件 `baseComponent`，然后使用 `vue.extend` 来创建一个新的组件 `newComponent`，这个新的组件继承了 `baseComponent` 的选项和方法，并且添加了自己的选项和方法。最后，我们使用 `newComponent` 创建了一个新的 Vue.js 实例，并且将它挂载到页面中。 总之，`vue.extend` 是一个非常有用的全局API，它可以方便地实现组件的复用和扩展，从而提高开发效率和代码可维护性

## 38、vue路由传参以及怎么取值？

在Vue中，可以通过路由传递参数来在不同的页面之间进行数据传递。具体步骤如下：

1. 在路由配置中设置参数 在路由配置中，可以通过在path中使用冒号`:`来定义参数，例如：

   ```js
   {
     path: '/users/:id',
     component: User
   }
   ```

   这里定义了一个名为id的参数，表示在访问 `/users/123` 时，参数id的值为123。

   \2. 在组件中获取参数 在组件中可以通过$router对象的params属性来获取参数，例如：

   ```js
   export default {
     name: 'User',
     created() {
       console.log(this.$route.params.id)
     }
   }
   ```

   这里通过console.log打印出了路由参数id的值。 另外，如果需要在路由跳转时传递参数，可以通过$router对象的push方法传递query参数，例如：

   ```js
   this.$router.push({ path: '/users', query: { id: 123 }})
   ```

   在接收方的组件中可以通过$router对象的query属性来获取传递的参数，例如：

   ```js
   console.log(this.$route.query.id)
   ```

   

## 39、路由守卫以及作用是什么？

路由守卫是Vue Router提供的一种机制，用于在导航到某个路由前或路由离开前进行一些控制或操作。通过路由守卫，我们可以在路由跳转时进行权限控制、登录验证、数据处理等操作，以及在路由跳转后进行一些特定的操作。

Vue Router提供了三种类型的路由守卫：

1. 全局前置守卫 全局前置守卫通过router.beforeEach注册，用于在路由跳转前进行拦截和处理。可以用来进行登录验证、权限控制等操作。如果要跳转到的路由需要进行登录验证，但当前用户未登录，则可以将用户重定向到登录页。如果要跳转到的路由需要进行权限控制，但当前用户没有权限，则可以提示用户无法访问该页面。
2. 路由独享守卫 路由独享守卫通过在路由配置中添加beforeEnter函数实现，用于在路由跳转前对该路由进行拦截和处理。与全局前置守卫不同的是，路由独享守卫只作用于当前路由，而不影响全局。
3. 组件内守卫 组件内守卫分为三种类型：beforeRouteEnter、beforeRouteUpdate和beforeRouteLeave。beforeRouteEnter在路由跳转到该组件前调用，beforeRouteUpdate在当前路由对应的组件复用时调用，beforeRouteLeave在离开当前路由对应的组件时调用。这三种守卫常用于在路由跳转前、路由复用时、路由离开时对组件进行数据处理。 总之，路由守卫的作用是在进行路由跳转前或路由离开前进行一些控制或操作，使得应用更加稳健和安全。

## 40、vue路由如何切换路由模式？

在Vue中，路由模式有两种：hash模式和history模式。默认情况下，Vue的路由模式是hash模式。如果需要切换路由模式，可以通过Vue Router提供的mode属性实现。

1. hash模式 hash模式是Vue默认的路由模式，以#号作为路由地址与参数的分隔符。hash模式的特点是浏览器不会向服务器发送请求，因此不需要进行特殊的服务器配置。要切换回hash模式，只需要在Vue Router的实例中设置mode属性为'hash'即可：

   ```js
   const router = new VueRouter({
     mode: 'hash',
     routes: [...]
   })
   ```

   2.history模式 history模式使用HTML5中的History API来实现，以正常的URL路径作为路由地址与参数的分隔符。history模式的特点是浏览器会向服务器发送请求，因此需要进行特殊的服务器配置。要切换到history模式，只需要在Vue Router的实例中设置mode属性为'history'即可：

   ```js
   const router = new VueRouter({
     mode: 'history',
     routes: [...]
   })
   ```

   需要注意的是，在使用history模式时，需要将所有的路由请求都重定向到index.html文件中。这可以通过服务器的配置文件实现，具体可以参考Vue Router的官方文档。

## 41、路由hash模式和history的区别？

路由模式有两种，分别是hash模式和history模式。

1. hash模式 hash模式是Vue Router默认的路由模式，以#号作为路由地址与参数的分隔符。hash模式的特点是浏览器不会向服务器发送请求，因此不需要进行特殊的服务器配置。hash模式的优点是兼容性好，可以在各种浏览器和旧版浏览器中使用，同时也可以避免浏览器缓存等问题。hash模式的缺点是URL中包含#号，不太美观，不利于SEO。
2. history模式 history模式使用HTML5中的History API来实现，以正常的URL路径作为路由地址与参数的分隔符。history模式的特点是浏览器会向服务器发送请求，因此需要进行特殊的服务器配置。history模式的优点是URL更加美观，利于SEO，同时也可以利用History API实现前进、后退等浏览器操作。history模式的缺点是兼容性较差，需要在服务器进行特殊配置，否则会出现404错误。 因此，选择使用哪种路由模式需要根据具体情况进行选择。如果需要考虑兼容性和缓存等问题，可以选择hash模式；如果需要考虑URL的美观和SEO等问题，可以选择history模式，但需要进行服务器的特殊配置。

## 42、vue2中如何给一个板块添加动画？

在Vue2中，给一个板块添加动画可以通过Vue提供的transition组件来实现。transition组件是Vue提供的用于在元素插入或删除时添加过渡效果的组件，可以通过设置不同的过渡类名来实现不同的动画效果。

具体实现步骤如下：

1. 在需要添加动画的板块外包裹一个transition组件，并设置name属性，例如：

   ```css
   <transition name="fade">
     <div class="box"></div>
   </transition>
   ```

   2.在CSS中定义不同的过渡类名，例如：

   ```css
   .fade-enter-active, .fade-leave-active {
     transition: opacity .5s;
   }
   .fade-enter, .fade-leave-to {
     opacity: 0;
   }
   ```

   其中，fade-enter-active和fade-leave-active类名分别表示元素进入和离开时的过渡状态，fade-enter和fade-leave-to类名分别表示元素进入和离开时的初始和结束状态。 需要注意的是，如果需要实现不同的动画效果，可以在CSS中定义不同的过渡类名，并在transition组件的name属性中设置对应的类名。 除了通过CSS定义过渡效果外，transition组件还提供了一些钩子函数，例如before-enter、enter、after-enter、before-leave、leave、after-leave等，可以在这些钩子函数中自定义动画效果。

## 43、vue中路由地址不刷新(url更新了，页面不更新)怎么解决？

出现路由地址不刷新，但URL更新了的情况，一般有两种可能性：

1. 路由组件使用了keep-alive缓存，导致组件没有重新渲染 解决方法：在需要刷新的路由组件中，可以通过在activated生命周期钩子函数中手动更新数据，从而实现组件的重新渲染。例如：

   ```js
   export default {
     data() {
       return {
         content: ''
       }
     },
     activated() {
       this.content = ''
       this.$nextTick(() => {
         this.content = '更新后的内容'
       })
     }
   }
   ```

   2.路由参数没有发生变化，导致组件没有重新渲染 解决方法：在路由参数没有发生变化的情况下，可以通过监听$route对象的变化来实现组件的重新渲染。例如：

   ```js
   export default {
     data() {
       return {
         content: ''
       }
     },
     watch: {
       $route(to, from) {
         this.content = ''
         this.$nextTick(() => {
           this.content = '更新后的内容'
         })
       }
     }
   }
   ```

   在watch选项中监听$route对象的变化，在$route变化时手动更新数据，从而实现组件的重新渲染。 需要注意的是，手动更新数据时，需要使用Vue的$nextTick方法确保数据更新后再重新渲染组件。

## 44、vue中怎么实现组件强制刷新？

在Vue中，可以通过设置key属性来实现组件的强制刷新。当组件的key值发生变化时，Vue会强制重新渲染组件，从而实现组件的强制刷新。 具体实现方法如下：

1. 在需要强制刷新的组件外包裹一个组件，并设置include属性，例如：

   ```html
   <keep-alive :include="['componentName']">
     <component :is="'componentName'" :key="componentKey"></component>
   </keep-alive>
   ```

   其中，componentName表示需要强制刷新的组件名称，componentKey表示组件的key值，可以设置为一个动态变量。 2. 在需要强制刷新组件的父组件中，通过修改componentKey值来触发组件的强制刷新，例如：

   ```js
   export default {
     data() {
       return {
         componentKey: 0
       }
     },
     methods: {
       refreshComponent() {
         this.componentKey += 1
       }
     }
   }
   ```

   通过定义一个动态变量componentKey，并在refreshComponent方法中修改componentKey值，从而触发组件的重新渲染，实现组件的强制刷新。 需要注意的是，使用组件时需要注意组件的状态缓存，如果需要每次都重新加载数据，可以在activated生命周期钩子函数中手动清空数据。

## 45、keep-alive的作用？

在Vue中，组件是用于缓存已经渲染过的组件实例的组件。它可以在组件切换时将之前的组件状态缓存起来，待下次使用时再次渲染，从而提高应用的性能。 

组件的主要作用有以下几点：

1. 缓存组件状态：当组件被包裹在组件中时，在组件切换时会将之前的组件状态缓存起来，待下次使用时再次渲染。这样可以避免每次重新渲染组件时都要重新执行组件的生命周期钩子函数和数据初始化等操作，从而提高应用的性能。
2. 控制组件的销毁和创建：当组件被包裹在组件中时，组件在被销毁时不会被直接销毁，而是会被放入一个缓存池中。当需要重新使用组件时，会从缓存池中取出组件实例并重新渲染。这样可以控制组件的销毁和创建，避免频繁的组件销毁和创建带来的性能损失。
3. 提供activated和deactivated钩子函数：当组件被包裹在组件中时，会提供activated和deactivated两个生命周期钩子函数。在组件被缓存时，会触发deactivated钩子函数，在组件被重新使用时，会触发activated钩子函数。可以在这两个钩子函数中进行组件状态的保存和恢复操作。 需要注意的是，缓存组件状态也有一定的缺点，例如占用一定的内存空间，可能会导致内存泄漏等问题。因此，需要根据实际情况合理使用组件。

## 46、父子组件的生命周期的执行顺序？

在Vue中，父子组件的生命周期钩子函数是有一定的执行顺序的，具体如下：

1. 父组件beforeCreate钩子函数
2. 父组件created钩子函数
3. 父组件beforeMount钩子函数
4. 子组件beforeCreate钩子函数
5. 子组件created钩子函数
6. 子组件beforeMount钩子函数
7. 子组件mounted钩子函数
8. 父组件mounted钩子函数
9. 父组件beforeUpdate钩子函数
10. 子组件beforeUpdate钩子函数
11. 子组件updated钩子函数
12. 父组件updated钩子函数
13. 父组件beforeDestroy钩子函数
14. 子组件beforeDestroy钩子函数
15. 子组件destroyed钩子函数
16. 父组件destroyed钩子函数 需要注意的是，在父子组件的生命周期钩子函数执行过程中，先执行父组件的钩子函数，再执行子组件的钩子函数。在子组件的mounted钩子函数执行完毕后，才会执行父组件的mounted钩子函数。在更新和销毁组件时，也会先执行父组件的钩子函数，再执行子组件的钩子函数。 另外，如果在子组件中使用了元素，父组件的钩子函数会在子组件的钩子函数执行之前调用。

## 47、vue2和vue3的区别？

Vue2和Vue3的主要区别如下：

1. 性能优化：Vue3通过重写响应式系统、编译器和虚拟DOM等方面进行了性能优化，相比Vue2更加高效。
2. Composition API：Vue3引入了Composition API，可以更灵活、更方便地组织组件逻辑，而不是基于选项的API。
3. 模板编译：Vue3的模板编译器使用了新的基于标记的编译器，支持更多的语法和更好的错误提示。
4. 全局API修改：Vue3中的全局API（如Vue、Vue.directive、Vue.filter）都被移动到了一个单独的模块中，需要手动引入。
5. 新的组件：Vue3引入了新的组件，如Teleport和Suspense，可以更方便地处理异步组件和动态组件的渲染。
6. Tree-Shaking：Vue3支持Tree-Shaking，可以更好地优化打包体积。
7. TypeScript支持：Vue3对TypeScript的支持更加完善，可以更好地进行类型检查和编写类型安全的代码。 需要注意的是，Vue3与Vue2在使用上有一些不兼容的地方，例如在Vue3中，需要使用createApp方法创建应用实例，而不是直接使用Vue构造函数。因此，需要仔细阅读Vue3的文档，并进行相关的迁移工作。

## 48、WebSocket？

WebSocket是HTML5规范中的一种在单个TCP连接上进行全双工通信的协议。它通过在客户端和服务器之间建立一个套接字连接，实现了在一个单独的TCP连接上进行双向通信，能够更快地传递数据，降低了服务器的负载，并且能够更好地支持实时性应用。 WebSocket协议的特点如下：

1. 基于TCP：WebSocket协议是基于TCP协议的，保证了数据传输的可靠性和稳定性。
2. 实时性：WebSocket协议能够更好地支持实时性应用，例如在线聊天、在线游戏等。
3. 双向通信：WebSocket协议能够在一个单独的TCP连接上进行双向通信，避免了HTTP的“请求-响应”模式，能够更快地传递数据。
4. 低延迟：WebSocket协议的通信延迟比HTTP协议更低，能够更好地支持实时性应用。 在Web应用中，可以使用JavaScript的WebSocket API来实现WebSocket的通信。其中，WebSocket API提供了WebSocket对象，可以用于创建WebSocket连接、发送和接收数据等操作。在Vue应用中，可以使用Vue的插件vue-native-websocket来实现WebSocket的集成，该插件提供了WebSocket连接状态的监控、重连机制等功能，可以更好地支持实时性应用的开发。

## 49、什么是长链接和短链接？

长链接和短链接都是指在网络通信中建立的连接类型，具体如下：

1. 长链接（Keep-Alive）：是指在一次HTTP请求中，客户端和服务器建立一个TCP连接，保持连接状态，可以发送多个HTTP请求，直到客户端关闭连接或者服务器主动关闭连接。长链接可以减少建立和关闭连接所花费的时间和资源，提高网络通信的效率，适用于客户端和服务器之间需要频繁通信的场景，例如实时聊天、直播等。
2. 短链接：是指在一次HTTP请求中，客户端和服务器建立一个TCP连接，发送一次HTTP请求后立即关闭连接。每次请求都建立和关闭连接，网络通信的效率较低，但适用于客户端和服务器之间通信不频繁的场景，例如普通的网页浏览等。 需要注意的是，长链接和短链接都有各自的优缺点，应根据具体的业务需求选择合适的连接类型。同时，长链接也需要注意长时间保持连接会消耗服务器的资源，需要进行适当的优化和控制。

## 50、vue3中ref 的作用？

在Vue3中，`ref`是一个函数，它的作用是创建一个响应式的引用对象，可以用来获取模板中的元素、组件和数据等。具体来说，`ref`可以用来实现以下功能：

1. 获取元素：可以使用`ref`函数获取模板中的元素，然后对其进行操作。例如：

   ```html
   <template>
     <div ref="myDiv">Hello, World!</div>
   </template>
   <script>
   import { ref } from 'vue';
   export default {
     setup() {
       const myDiv = ref(null);
       console.log(myDiv.value); // 输出 null
       onMounted(() => {
         console.log(myDiv.value); // 输出 <div>...</div>
       });
       return {
         myDiv
       };
     }
   };
   </script>
   ```

   2.获取组件实例：可以使用`ref`函数获取组件实例，然后对其进行操作。例如：

   ```html
   <template>
     <my-component ref="myComponent"></my-component>
   </template>
   <script>
   import { ref } from 'vue';
   import MyComponent from './MyComponent.vue';
   export default {
     components: {
       MyComponent
     },
     setup() {
       const myComponent = ref(null);
       console.log(myComponent.value); // 输出 null
       onMounted(() => {
         console.log(myComponent.value); // 输出 MyComponent 组件实例
       });
       return {
         myComponent
       };
     }
   };
   </script>
   ```

   3.获取数据：可以使用`ref`函数获取响应式的数据，然后对其进行操作。例如：

   ```html
   <template>
     <div>{{ count }}</div>
   </template>
   <script>
   import { ref } from 'vue';
   export default {
     setup() {
       const count = ref(0);
       console.log(count.value); // 输出 0
       setInterval(() => {
         count.value++;
       }, 1000);
       return {
         count
       };
     }
   };
   </script>
   ```

   需要注意的是，`ref`返回的是一个包含`.value`属性的对象，需要通过`.value`属性来访问数据。同时，`ref`创建的是响应式的对象，当数据发生变化时，Vue会自动更新视图。

## 51、v3中reactive的作用？

在Vue3中，`reactive`是一个函数，它的作用是将一个普通的JavaScript对象转换为响应式的对象。具体来说，`reactive`可以用来实现以下功能：

1. 实现数据响应式：将一个普通的JavaScript对象转换为响应式的对象，当对象的属性发生变化时，Vue会自动更新视图。例如：

   ```js
   import { reactive } from 'vue';
   const state = reactive({
     count: 0
   });
   setInterval(() => {
     state.count++;
   }, 1000);
   ```

   2.实现深度响应式：`reactive`函数可以实现对象的深度响应式，即当对象嵌套有对象时，内部对象的属性发生变化时，Vue也会自动更新视图。例如：

   ```js
   import { reactive } from 'vue';
   const state = reactive({
     user: {
       name: '张三',
       age: 18
     }
   });
   setInterval(() => {
     state.user.age++;
   }, 1000);
   ```

   3.实现属性访问代理：`reactive`函数还可以将响应式对象的属性访问代理到顶层，可以直接访问对象的属性，而不需要通过`.value`属性。例如：

   ```js
   import { reactive } from 'vue';
   const state = reactive({
     count: 0
   });
   console.log(state.count); // 输出 0
   setInterval(() => {
     state.count++;
   }, 1000);
   ```

   需要注意的是，`reactive`函数创建的是响应式的对象，而不是普通的JavaScript对象，需要通过`.value`属性来访问对象的属性，否则会抛出错误。同时，`reactive`函数创建的响应式对象只能在`setup`函数中使用，否则会抛出错误。

## 52、toRef和toRefs的区别?

`toRef`和`toRefs`都是Vue3中用来处理响应式对象的函数，但是它们的作用略有不同。 `toRef`的作用是将一个响应式对象的属性转换为一个普通的引用，即将一个响应式对象的属性转换为一个独立的响应式引用，这个引用具有响应式特性，但是它不会自动追踪响应式对象的变化。当原始的响应式对象的属性发生变化时，这个引用的值也会更新，但是这个引用不会自动触发更新视图。

例如：

```js
import { reactive, toRef } from 'vue';
const state = reactive({
  count: 0
});
const countRef = toRef(state, 'count');
console.log(countRef.value); // 输出 0
setInterval(() => {
  state.count++;
  console.log(countRef.value); // 输出 1, 2, 3, ...
}, 1000);
```

`toRefs`的作用是将一个响应式对象的属性转换为一组普通的引用，这些引用具有响应式特性，而且会自动追踪响应式对象的变化。当原始的响应式对象的属性发生变化时，这些引用的值也会更新，并自动触发更新视图。例如：

```js
import { reactive, toRefs } from 'vue';
const state = reactive({
  count: 0
});
const refs = toRefs(state);
console.log(refs.count.value); // 输出 0
setInterval(() => {
  state.count++;
  console.log(refs.count.value); // 输出 1, 2, 3, ...
}, 1000);
```

需要注意的是，`toRef`和`toRefs`都是用来处理响应式对象的函数，只有响应式对象的属性才能被转换。同时，对于`toRefs`返回的对象，需要通过`.value`属性来访问属性的值。

## 53、Ts的类型约束？

在TypeScript中，类型约束是一种用来确保代码正确性的方式，它可以在编译期间检查代码中的类型错误，避免在运行时出现类型错误。TypeScript提供了多种类型约束方式，包括以下几种：

1. 类型注解：使用冒号（:）来标记变量、函数参数、函数返回值等的类型，例如：

   ```tsx
   let num: number = 123;
   function add(a: number, b: number): number {
     return a + b;
   }
   ```

   2.接口：使用`interface`关键字定义一个接口，用来描述对象的形状，例如：

   ```tsx
   interface Person {
     name: string;
     age: number;
   }
   function sayHello(person: Person) {
     console.log(`Hello, ${person.name}!`);
   }
   ```

   3.类型别名：使用`type`关键字定义一个类型别名，用来给一个类型起一个新的名字，例如：

   ```tsx
   type MyString = string;
   type MyNumber = number;
   function add(a: MyNumber, b: MyNumber): MyNumber {
     return a + b;
   }
   ```

   4.枚举：使用`enum`关键字定义一个枚举类型，用来枚举所有可能的取值，例如：

   ```
   enum Color {
     Red,
     Green,
     Blue
   }
   function getColorName(color: Color): string {
     switch (color) {
       case Color.Red:
         return '红色';
       case Color.Green:
         return '绿色';
       case Color.Blue:
         return '蓝色';
       default:
         return '未知颜色';
     }
   }
   ```

   6.泛型：使用`<T>`语法定义一个泛型类型，用来支持多种类型的输入，例如：

   ```
   function reverse<T>(arr: T[]): T[] {
     return arr.reverse();
   }
   console.log(reverse([1, 2, 3])); // 输出 [3, 2, 1]
   console.log(reverse(['a', 'b', 'c'])); // 输出 ['c', 'b', 'a']
   ```

   

## 54、强缓存和协商缓存?

​		强缓存和协商缓存都是浏览器缓存机制的一种方式，用于提高页面的加载速度和减少网络带宽的消耗。 强缓存是指浏览器直接从本地缓存中获取资源的方式，而不需要向服务器发送请求。当浏览器第一次请求资源时，服务器会在响应头中设置Cache-Control或者Expires字段，告诉浏览器该资源的缓存时间。当浏览器再次请求该资源时，会先检查本地缓存中是否存在该资源，如果存在并且未过期，则直接从本地缓存中获取资源，不会向服务器发送请求。

​		 协商缓存是指浏览器向服务器发送请求，服务器通过比较请求头中的If-Modified-Since或者If-None-Match字段和资源在服务器上的最后修改时间或者唯一标识符来判断资源是否发生变化。如果资源未发生变化，则服务器返回304 Not Modified状态码，告诉浏览器可以使用本地缓存中的资源。如果资源发生变化，则服务器返回新的资源，并更新本地缓存中的资源。 强缓存和协商缓存都有各自的优缺点。强缓存可以减少网络带宽的消耗，加快页面加载速度，但是无法及时获取最新的资源。而协商缓存可以及时获取最新的资源，但是会增加服务器的负担和网络带宽的消耗。因此，在具体应用中，需要根据实际情况选择适合的缓存策略。

## 55、node怎么实现连接数据库？

Node.js可以通过模块化的方式连接数据库。常见的数据库有MySQL、MongoDB、Redis等，以下分别介绍不同数据库的连接方式。

1. 连接MySQL 连接MySQL需要使用第三方模块mysql2，安装命令如下：

2. npm install mysql2

3. 连接MySQL的代码如下：

   ```js
   const mysql = require('mysql2');
   const connection = mysql.createConnection({
     host: 'localhost', // 数据库主机名
     user: 'root', // 数据库用户名
     password: 'password', // 数据库密码
     database: 'test' // 数据库名
   });
   connection.connect((err) => {
     if (err) {
       console.error('error connecting: ' + err.stack);
       return;
     }
     console.log('connected as id ' + connection.threadId);
   });
   connection.end();
   ```

   4.连接MongoDB的代码如下：

   ```js
   const mongoose = require('mongoose');
   mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true, useUnifiedTopology: true});
   const db = mongoose.connection;
   db.on('error', console.error.bind(console, 'connection error:'));
   db.once('open', () => {
     console.log('connected to mongodb');
   });
   db.close();
   ```

   

## 56、v3中setup为什么要写return？

在Vue 3中，组件的setup选项是一个新的选项，用于替代Vue 2.x中的beforeCreate和created钩子函数。setup函数在组件实例创建之前执行，并且它必须返回一个对象，该对象包含模板中需要使用的数据、方法以及生命周期钩子等等。 在setup函数中，如果需要将数据或方法暴露给模板，则需要将它们返回。如果没有返回，则模板无法访问这些数据或方法。因此，在Vue 3中，setup函数中需要添加return语句，将需要暴露给模板的数据或方法返回。

## 57、v3中如何监听一个数据变化？

在Vue 3中，可以使用watchEffect或watch函数来监听一个数据变化。

1. watchEffect watchEffect是一个立即执行的watch函数，它会自动追踪响应式数据的变化，并在变化时执行回调函数。watchEffect的用法如下：

2. ```
   import { watchEffect } from 'vue';
   const state = reactive({
     count: 0
   });
   watchEffect(() => {
     console.log(state.count);
   });
   ```

   在这个例子中，使用watchEffect监听state.count的变化，并在变化时打印新的值。

   3.watch 

   watch函数需要传入两个参数，第一个参数是要监听的数据或表达式，第二个参数是回调函数。当监听的数据变化时，回调函数会被执行。watch的用法如下：

   ```js
   import { watch } from 'vue';
   const state = reactive({
     count: 0
   });
   watch(
     () => state.count,
     (newValue, oldValue) => {
       console.log(`state.count从${oldValue}变为${newValue}`);
     }
   );
   ```

   在这个例子中，使用watch监听state.count的变化，并在变化时打印新旧值。 需要注意的是，在Vue 3中，watch和watchEffect的区别在于watchEffect会立即执行一次回调函数，而watch不会。同时，watchEffect返回一个停止追踪函数，可以手动停止监听。而watch没有返回值，必须手动停止监听。

## 58、v3中createApp的作用？

在Vue 3中，createApp函数是一个工厂函数，用于创建Vue实例。它接受一个根组件作为参数，并返回一个应用程序实例，该实例可以用于挂载到DOM元素上。 

createApp的作用有以下几点：

1. 创建Vue实例 使用createApp函数可以创建一个Vue实例，这个实例可以包含一个或多个组件、指令、插件等等。
2. 安装插件 createApp函数还可以用于安装插件。在Vue 3中，插件的安装方式有所变化，需要使用app.use()方法来安装插件。
3. . 全局配置 createApp函数还可以用于全局配置，比如配置Vue的生产环境提示信息、自定义指令等等。

## 59、什么是原型和原型链？

​		在JavaScript中，每个对象都有一个原型（prototype）对象，它相当于对象的父对象，它定义了对象的共享属性和方法。当我们访问一个对象的属性或方法时，如果这个对象本身没有定义这个属性或方法，那么它就会去它的原型对象中查找，如果原型对象中也没有找到，则会继续往上查找原型对象的原型对象，直到找到Object.prototype为止，这就是原型链（prototype chain）的概念。 在JavaScript中，原型链是通过每个对象的__proto__属性来实现的，每个对象的__proto__属性指向它的原型对象。如果一个对象的原型对象也有原型对象，那么它的__proto__属性就指向它的父对象的原型对象，这样就形成了一条原型链。 举个例子，假设有一个对象a，它的原型对象是b，b的原型对象是c，c的原型对象是Object.prototype，那么原型链就是a -> b -> c -> Object.prototype。当我们访问a的一个属性时，JavaScript会先查找a自身是否有这个属性，如果没有，它就会去a的原型对象b中查找，如果b中也没有，它就会去b的原型对象c中查找，直到找到Object.prototype，如果还没有找到，就会返回undefined。 原型和原型链是JavaScript中的重要概念，它们是理解JavaScript面向对象编程的基础，也是理解JavaScript中继承的关键。

## 60、地址栏输入url地址后发生了什么？

当我们在浏览器的地址栏中输入一个URL地址并按下回车键后，会触发以下一系列的过程：

1. DNS解析：浏览器会先检查本地缓存中是否有该域名对应的IP地址，如果没有则向DNS服务器发送请求进行解析，并将解析结果缓存到本地缓存中。
2. 建立TCP连接：浏览器通过TCP协议向服务器发起连接请求，如果服务器同意连接，则建立TCP连接。
3. 发送HTTP请求：浏览器向服务器发送HTTP请求，请求中包含了请求方法、URL、HTTP版本、请求头等信息。
4. 服务器处理请求并返回HTTP响应：服务器接收到浏览器发送的请求后，会根据请求的内容进行处理，并返回HTTP响应，响应中包含了HTTP状态码、响应头、响应正文等信息。
5. 浏览器处理响应并渲染页面：浏览器接收到服务器返回的响应后，会根据响应的内容进行处理，并将响应正文渲染为页面显示给用户。
6. 断开TCP连接：当页面渲染完成后，浏览器会断开与服务器之间的TCP连接，这样就完成了一次HTTP请求过程。 需要注意的是，上述过程是一个简化的描述，实际上还包含了很多细节和复杂的处理，比如HTTP缓存、HTTPS加密、HTTP2协议等等。

## 61、HTTP和HTTPS的区别？

HTTP和HTTPS都是用于客户端和服务器之间进行通信的协议，它们的主要区别如下：

1. 安全性：HTTP是明文传输数据，数据在传输过程中可以被中间人窃取和篡改，因此不安全；而HTTPS使用SSL/TLS加密技术对数据进行加密传输，可以保证数据传输的安全性。
2. 端口号：HTTP使用的默认端口是80，而HTTPS使用的默认端口是443。
3. 证书：HTTPS需要使用SSL/TLS证书来验证服务器的身份，确保通信的安全性，而HTTP没有这个要求。
4. 速度：由于HTTPS需要进行加密解密操作，因此比HTTP要慢一些。
5. 缓存：由于HTTPS的数据是加密的，因此不能被缓存，这也是它比HTTP要慢的一个原因。 总之，HTTP是一种不安全的协议，适用于不需要保密的场景，而HTTPS则是一种安全的协议，适用于需要保密的场景，比如网上银行、电子商务等。

## 62、什么是事件流以及其传播机制？

事件流（Event Flow）是指事件在页面中传递的顺序，它有两种传播机制：冒泡和捕获。

1. 冒泡传播：事件首先在触发它的元素上触发，然后沿着DOM树向上依次触发父元素的该事件，直到传播到document对象为止。比如，当我们在一个按钮上点击鼠标时，首先会触发按钮的click事件，然后会依次触发按钮的父元素的click事件，直到传播到document对象为止。
2. 捕获传播：与冒泡传播相反，事件首先从document对象开始触发，然后沿着DOM树向下依次触发子元素的该事件，直到触发事件的元素为止。比如，当我们在一个按钮上点击鼠标时，首先会触发document对象的click事件，然后会依次触发按钮的父元素的click事件，直到最终触发按钮的click事件。 在事件流中，事件的传播过程是从外到内的，也就是说，事件先经过捕获阶段，然后再经过冒泡阶段。在实际开发中，我们可以利用事件捕获和冒泡机制来实现事件的委托、事件的拦截和阻止事件的传播等功能。

## 63、什么是懒加载和预加载？

懒加载和预加载都是前端优化的一种方式，它们的主要区别如下：

1. 懒加载：也称为延迟加载，指的是在页面滚动到某个位置时，才加载该位置对应的图片或内容。懒加载可以减少页面的加载时间和带宽的使用，提高用户体验。常见的懒加载技术有Intersection Observer和lazyload等。
2. 预加载：指的是在页面加载完成后，提前加载图片、音频、视频等资源，以提高用户在访问页面时的响应速度和体验。预加载可以通过JavaScript动态创建![img]()标签、标签等方式来实现。 总之，懒加载和预加载都是优化网页性能的有效手段，需要根据具体的场景选择合适的方式来进行优化。

## 64、数组的方法forEach和map的区别？

forEach和map都是数组的方法，它们的主要区别如下：

1. 返回值：forEach没有返回值，而map返回一个新的数组。
2. 使用方式：forEach可以直接对数组进行遍历操作，而map需要接收一个回调函数作为参数，并且需要使用返回的新数组来接收操作后的结果。
3. 作用：forEach主要用于遍历数组并对每个元素进行操作，而map则是对每个元素进行操作并返回一个新的数组。
4. 是否改变原数组：forEach不会改变原数组，而map会返回一个新的数组并修改原数组。 通常情况下，如果我们只是需要对数组进行遍历操作，那么我们可以使用forEach方法；如果需要对每个元素进行操作并返回一个新的数组，则可以使用map方法。

## 65、ES6中Set和Map的原理?

Set和Map是ES6中新增的数据结构，它们的原理分别如下：

1. Set Set是一种类似于数组的数据结构，它的特点是成员的值都是唯一的，没有重复的值。Set内部使用哈希表存储数据，因此插入和查找的时间复杂度都是O(1)。 Set的主要方法如下：

- add(value)：向Set实例添加一个值，返回Set实例本身。
- delete(value)：删除Set实例中的一个值，返回一个布尔值，表示删除是否成功。
- has(value)：返回一个布尔值，表示Set实例中是否存在该值。
- clear()：清空Set实例，没有返回值。

1. Map Map是一种类似于对象的数据结构，它的特点是可以使用任何类型的值作为键名，包括对象。Map内部使用哈希表存储数据，因此插入和查找的时间复杂度都是O(1)。 Map的主要方法如下：

- set(key, value)：向Map实例添加一个键值对，返回Map实例本身。
- get(key)：返回Map实例中键对应的值，如果键不存在则返回undefined。
- delete(key)：删除Map实例中指定的键值对，返回一个布尔值，表示删除是否成功。
- has(key)：返回一个布尔值，表示Map实例中是否存在该键。
- clear()：清空Map实例，没有返回值。 总之，Set和Map都是一种高效的数据结构，可以用于存储和操作大量的数据，是ES6中非常实用的特性。

## 66、v3里面实现组件通信的方法？

在Vue.js 3中，组件之间的通信可以通过以下几种方式来实现：

1. props和emit 在Vue.js 3中，我们仍然可以使用props和emit方式来实现父组件向子组件传递数据和子组件向父组件发送事件的通信方式。
2. provide和inject provide和inject是Vue.js 3中新增的API，用于实现祖先组件向后代组件传递数据的通信方式。使用provide提供数据，然后在后代组件中使用inject注入该数据，就可以在后代组件中访问到祖先组件提供的数据了。
3. ref和$refs ref和$refs也是Vue.js 3中新增的API，用于在父组件中访问子组件的实例或子元素的引用。通过ref指定子组件或DOM元素的引用名，然后在父组件中使用$refs对象就可以访问到对应的实例或引用了。
4. 全局事件总线 在Vue.js 3中，我们可以使用Vue实例作为全局事件总线，通过$emit方法触发事件，然后在其他组件中使用$on方法监听该事件，就可以实现跨组件通信了。
5. Vuex Vuex是Vue.js 3中的状态管理库，可以用于管理全局的状态数据。通过在组件中使用Vuex提供的API，就可以实现跨组件的状态共享和通信了。 总之，在Vue.js 3中，我们有多种方式可以实现组件之间的通信，需要根据具体的场景选择合适的方式来进行实现。

## 67、vue虚拟dom以及diff算法的理解？

​		Vue使用虚拟DOM以及diff算法来高效地更新DOM，提高性能和渲染效率。 虚拟DOM是一种内存中的树形数据结构，它使用JavaScript对象来模拟真实的DOM节点。在Vue中，每个组件都有一个对应的虚拟DOM树，当组件状态发生变化时，Vue会重新计算虚拟DOM树，然后将新的虚拟DOM树与旧的虚拟DOM树进行比较，找出需要更新的部分，然后只更新需要更新的部分，从而避免了无谓的DOM操作。 diff算法是虚拟DOM的核心算法，它用于比较新旧虚拟DOM树的差异，找出需要更新的部分。diff算法的基本思路是将新旧虚拟DOM树的同一层节点进行比较，如果节点类型不同，则直接替换节点；如果节点类型相同，则比较节点的属性和子节点，如果有差异，则更新属性和子节点。

diff算法的优化策略包括：

1. 同级比较：只比较同一层级的节点，不跨级比较，减少比较次数。
2. key值比较：如果节点有唯一的标识key，则可以通过key值来判断节点是否发生变化，从而减少比较次数。
3. 剪枝操作：如果节点类型不同，则不需要进行子节点的比较，直接替换节点；如果节点类型相同，则只比较有变化的属性和子节点，不需要比较全部属性和子节点。 总之，虚拟DOM以及diff算法是Vue提高性能和渲染效率的关键技术之一，通过使用虚拟DOM和diff算法，Vue可以快速地更新DOM，提高应用的性能和用户体验。

## 68、vue中nextTick的理解？

​		在Vue中，当我们修改数据后，DOM并不会立即更新，而是异步更新。这是因为Vue利用了异步更新队列的机制，将DOM更新操作放入队列中，并在下一个tick时执行更新操作，从而使得DOM更新可以进行批量处理，提高性能。 Vue提供了nextTick方法，用于在DOM更新后执行回调函数。nextTick方法接收一个回调函数作为参数，在DOM更新完成后会执行该回调函数。nextTick方法可以用来处理DOM更新后的操作，例如获取更新后的DOM节点、执行某些操作等。 需要注意的是，由于nextTick方法是异步执行的，因此在nextTick方法中获取到的DOM节点可能不是最新的，因此需要谨慎使用。如果需要在nextTick方法中执行一些操作，可以使用Vue提供的$nextTick方法，它会返回一个Promise对象，可以通过该对象的then方法来处理异步操作，确保获取到最新的DOM节点。 总之，nextTick方法是Vue中用于处理DOM更新后的回调函数的方法，它利用异步更新队列的机制，在下一个tick时执行回调函数，避免了无谓的DOM操作，提高了性能。

## 69、如何理解vue中渲染函数render中的h函数？

在Vue中，渲染函数render是用来生成虚拟DOM树的函数，它接收一个h函数作为参数，用于创建虚拟DOM节点。h函数是Vue提供的用于创建虚拟DOM节点的辅助函数，它接收三个参数：

1. 标签名或组件配置对象：用于指定节点的类型，可以是HTML标签名或组件配置对象。
2. 节点的属性或数据对象：用于指定节点的属性和数据，例如class、style、props等。
3. 子节点数组：用于指定节点的子节点，可以是文本节点、虚拟DOM节点或其他类型的节点。 h函数创建的虚拟DOM节点是一个JavaScript对象，它包含了节点的类型、属性和子节点等信息。渲染函数render会将h函数创建的虚拟DOM节点转换为真实的DOM节点，并将其插入到页面中。 需要注意的是，h函数创建的虚拟DOM节点是不可变的，一旦创建就不会再被修改。这与Vue的响应式机制是相对应的，Vue使用响应式数据来驱动视图的更新，而不是直接修改DOM节点。 总之，h函数是Vue中用于创建虚拟DOM节点的辅助函数，它接收三个参数，用于指定节点的类型、属性和子节点。在渲染函数render中，h函数用于创建虚拟DOM节点，从而生成虚拟DOM树，最终将其转换为真实的DOM节点，并插入到页面中。

## 70、有没有封装过组件？是怎么实现的？

## 71、vuex的原理？

Vuex是一个专门为Vue.js框架设计的状态管理库，它的核心原理是基于Flux和Redux架构思想的单向数据流模式。 Vuex中的数据流向是单向的，从组件发起一个dispatch，然后由Vuex Store接收并处理该Action，然后执行相应的Mutations来更新Store中的状态。最后，Store中更新的状态将被通知给所有订阅了这个状态的组件，从而使得组件及时响应状态的变化。 Vuex的核心概念包括:

- State: 定义了应用程序状态的数据结构，即存储在应用程序中的状态，类似于组件中的data属性，但是是全局共享的。
- Mutations: 用于修改State的函数，它们是同步的，只能通过commit函数调用。Mutation必须是同步的，这样才能确保状态的可预测性。
- Actions: 用于提交异步操作和封装复杂的业务逻辑，它们是异步的，可以调用多个Mutation，可以通过dispatch函数调用。
- Getters: 类似于组件中的计算属性，用于从Store中获取派生状态的值，这些状态可以基于一个或多个State的值计算得出。 通过这些核心概念，Vuex实现了一个中央存储库，让组件可以轻松地访问和修改状态，同时确保了状态的单向数据流动，从而使得应用程序的状态管理更加可控和可维护。

## 72、vue怎么根据不同环境打包？

在Vue中，我们可以使用不同的配置文件来根据不同的环境进行打包。常见的做法是使用两个不同的文件分别为production和development环境提供不同的配置。 首先，我们可以在项目根目录下创建两个不同的配置文件，例如`vue.config.dev.js`和`vue.config.prod.js`。 然后，我们可以在`package.json`中通过`scripts`命令来指定打包的环境：

```
"scripts": {
  "build:dev": "vue-cli-service build --mode development",
  "build:prod": "vue-cli-service build --mode production"
}
```

这里我们使用了`--mode`参数来指定打包的环境，`development`为开发环境，`production`为生产环境。 接着，我们需要在配置文件中设置不同的参数，例如：

```
// vue.config.dev.js
module.exports = {
  devServer: {
    port: 8080,
    open: true
  }
}
// vue.config.prod.js
module.exports = {
  publicPath: '/my-app/',
  productionSourceMap: false
}
```

在上面的示例中，我们分别设置了开发环境和生产环境的不同参数，例如`devServer`和`publicPath`。 最后，我们可以通过执行`npm run build:dev`或`npm run build:prod`命令来进行相应环境的打包，打包后的文件将会在`dist`目录下生成。

## 73、v2中createElement用过没？怎么使用的？

在Vue 2中，`createElement`是用于创建虚拟DOM节点的函数，它的作用类似于React中的`createElement`函数。我们可以使用`createElement`函数手动创建虚拟DOM节点，然后将其渲染到页面上，这样可以更加灵活地控制组件的渲染过程。 下面是一个使用`createElement`函数手动创建虚拟DOM节点的示例：

```
export default {
  render (createElement) {
    return createElement('div', {
      attrs: {
        id: 'app'
      }
    }, [
      createElement('h1', 'Hello World'),
      createElement('p', 'This is a demo')
    ])
  }
}
```

在上面的示例中，我们通过调用`createElement`函数来创建一个`div`节点，然后给它设置了一个`id`属性，最后在这个`div`节点中添加了一个`h1`节点和一个`p`节点。`createElement`函数的第一个参数是节点的标签名，第二个参数是节点的属性，第三个参数是节点的子节点，它可以是一个数组或者一个字符串。 除了直接调用`createElement`函数，我们还可以使用JSX语法来创建虚拟DOM节点：

```
export default {
  render () {
    return (
      <div id="app">
        <h1>Hello World</h1>
        <p>This is a demo</p>
      </div>
    )
  }
}
```

在上面的示例中，我们使用JSX语法来创建虚拟DOM节点，这样代码更加简洁易读。需要注意的是，使用JSX语法需要在项目中引入`babel-plugin-transform-vue-jsx`插件来进行转换。

## 74、keep-alive有什么用，有哪两个属性？

`keep-alive`是Vue提供的一个抽象组件，用于缓存组件的状态或避免重新渲染。其作用是在组件切换时，将被包裹的组件保存在缓存中，而不是直接销毁，这样可以提高组件的性能，并且可以避免一些不必要的数据请求或计算。 `keep-alive`组件有两个重要的属性，分别是`include`和`exclude`

- `include`：用于指定需要缓存的组件，可以是一个字符串或一个正则表达式。例如：

```
<keep-alive :include="'home'">
  <router-view/>
</keep-alive>
```

上面的代码中，我们将`include`属性设置为`'home'`，表示只缓存名称为`home`的组件。

- `exclude`：用于指定不需要缓存的组件，可以是一个字符串或一个正则表达式。例如：

- ```
  <keep-alive :exclude="'login'">
    <router-view/>
  </keep-alive>
  ```

  上面的代码中，我们将`exclude`属性设置为`'login'`，表示不缓存名称为`login`的组件。 需要注意的是，`include`和`exclude`属性不能同时使用，如果同时使用了这两个属性，`exclude`属性会覆盖`include`属性。另外，`keep-alive`组件只有在标签被切换时才会触发缓存，如果是同一个标签切换不同的数据则不会触发缓存。

## 75、nextTick有什么作用和setTimeout的区别?

`nextTick`是Vue提供的一个异步方法，它的作用是在下次DOM更新循环结束之后执行指定的回调函数。在Vue中，当我们修改了数据之后，由于Vue的响应式机制，会触发重新渲染视图，这个过程是异步的，也就是说，修改数据的代码执行完毕之后，视图并没有立即更新。如果我们需要在视图更新之后执行一些操作，就可以使用`nextTick`方法。

`nextTick`方法的使用示例：

```
Vue.nextTick(() => {
  // 在DOM更新循环结束之后执行的回调函数
})
```

与`setTimeout`方法相比，`nextTick`方法有以下几点区别：

1. `nextTick`方法是Vue提供的异步方法，它的执行时机在DOM更新循环结束之后，而`setTimeout`方法是纯粹的异步方法，它的执行时机是在指定的时间间隔之后。
2. `nextTick`方法在执行时会尽可能地利用浏览器的异步机制，以最快的速度执行回调函数，而`setTimeout`方法则需要等待指定的时间间隔之后才能执行回调函数，如果指定的时间间隔太短，可能会影响性能。
3. `nextTick`方法的回调函数中可以访问到更新后的DOM节点，而`setTimeout`方法的回调函数中只能访问到更新前的DOM节点。 因此，如果我们需要在视图更新之后执行一些操作，应该优先选择使用`nextTick`方法。但如果我们需要延迟执行一些操作，并且对执行时机的精确度要求不高，可以使用`setTimeout`方法。

## 76、vue2中vue.use的作用？

`Vue.use`是Vue提供的一个插件安装方法，用于安装Vue插件。它的作用是在全局范围内注册一个Vue插件或者调用一个提供插件对象的install方法，以便我们可以在Vue实例中使用插件提供的功能。 `Vue.use`方法的使用示例：

```
// 安装一个Vue插件
Vue.use(MyPlugin)
// 安装一个提供插件对象的install方法
Vue.use({
  install: function (Vue, options) {
    // 注册组件、指令、过滤器等
  }
})
```

`Vue.use`方法接收一个插件作为参数，这个插件可以是一个对象，也可以是一个函数。如果插件是一个对象，它必须提供一个`install`方法，这个方法接收Vue构造函数作为第一个参数，以及可选的选项对象作为第二个参数。在`install`方法中，我们可以注册全局组件、指令、过滤器等。如果插件是一个函数，它会被直接调用，并且会将Vue构造函数作为参数传入，我们可以在这个函数中注册全局组件、指令、过滤器等。 需要注意的是，一个插件只能被安装一次，重复安装同一个插件会被忽略。如果我们需要在多个Vue实例中使用一个插件，可以在这些实例的创建之前调用`Vue.use`方法来安装插件。

## 77、vue-model为什么要绑定key？key的作用是什么?

在使用`v-model`指令绑定表单元素时，如果使用的是`v-for`指令循环渲染表单元素，那么就需要给每个表单元素绑定一个`key`属性。这是因为Vue在更新DOM时，会尽量复用已有的DOM节点，而不是重新创建节点。如果没有给表单元素绑定`key`属性，那么在更新DOM时，可能会出现一些意外的结果。

具体来说，`key`属性在`v-for`循环渲染中的作用有以下两个方面：

1. 帮助Vue识别每个节点的身份，从而尽可能地复用已有的DOM节点，提高性能。
2. 解决由于节点身份变更而导致的一些问题。例如，如果我们通过`v-for`循环渲染一个表单，并且在表单元素中使用了`v-model`指令绑定数据，那么在更新表单元素时，如果没有给表单元素绑定`key`属性，可能会导致绑定的数据出现错位的情况。这是因为Vue在更新DOM时，会根据节点的位置来确定节点的身份，如果节点的位置发生变化，那么绑定在这个节点上的数据就会发生错位。 因此，我们在使用`v-for`循环渲染表单元素时，一般需要给每个表单元素绑定一个唯一的`key`属性，以便Vue可以正确地识别每个节点的身份，并且可以避免出现一些意外的情况。

## 78、vue中watch和computed的区别？

`watch`和`computed`都是Vue中用于监听数据变化的方法，但是它们的作用和使用方式有所不同。

1. `watch`是一个观察者，用于监听数据变化并做出相应的响应。我们可以使用它来监听一个数据的变化并在回调函数中执行一些操作，例如发送网络请求、更新视图等。`watch`的使用方式是通过在Vue实例中定义一个`watch`对象来实现的，其中对象的属性是要监听的数据，属性值是一个函数，用于处理数据变化时要执行的操作。
2. `computed`是一个计算属性，用于根据已有的数据计算出一个新的值。我们可以使用它来计算一些需要依赖其他数据计算得出的值，例如过滤、格式化等。`computed`的使用方式是通过在Vue实例中定义一个`computed`对象来实现的，其中对象的属性是要计算的值的名称，属性值是一个函数，用于计算这个值。 区别如下：
3. `computed`是基于它所依赖的数据进行缓存的，只有当它依赖的数据发生变化时，才会重新计算，而`watch`则是当数据变化时做出相应的响应操作。
4. `computed`只有在其依赖的数据发生变化时才会重新计算，而`watch`则是无论数据是否发生变化都会执行。
5. `computed`一般用于对多个数据进行计算或者过滤的场景，而`watch`一般用于监听单个数据的变化并做出相应的响应。 因此，我们在使用Vue时，应该根据实际的业务场景选择合适的方法来监听数据变化。如果需要计算一个新的值，可以使用`computed`，如果需要监听一个数据的变化并做出相应的响应，可以使用`watch`。

## 79、React中hooks的使用规则？

React Hooks是React 16.8版本在函数式组件中提供的一种新特性，它可以让我们在不编写类组件的情况下使用状态和其他React特性。Hooks有以下几个使用规则：

1. 只在函数最外层调用Hooks。不要在循环、条件语句或者嵌套函数中调用Hooks，因为Hooks需要在函数组件的顶层调用，以确保它们的调用顺序是稳定的。
2. 只在React函数组件中调用Hooks。不要在普通的JavaScript函数中调用Hooks，因为只有在React函数组件中才能使用Hooks。
3. 只在顶层使用Hooks。不要在循环、条件语句或者嵌套函数中使用Hooks，因为Hooks需要在函数组件的顶层调用，以确保它们的调用顺序是稳定的。
4. 使用useState来声明状态。useState是最基本的Hook，它可以用来声明一个状态，并且返回一个数组，数组的第一个元素是当前的状态值，第二个元素是一个函数，可以用来更新状态值。
5. 使用useEffect来处理副作用。useEffect是一个可以在函数组件中处理副作用的Hook，副作用包括网络请求、订阅、定时器等操作。
6. 其他常用的Hooks还包括useContext、useReducer、useMemo、useCallback等，它们可以用来处理组件之间的通信、状态管理等问题。 总之，在使用Hooks时，需要遵循上述规则，以确保Hooks的正确使用，并且需要理解Hooks的具体实现原理，避免出现一些意外的问题。

## 80、setState是同步还是异步？

在React中，`setState`可以是同步的也可以是异步的，这取决于调用`setState`的方式和环境。 

当`setState`是在React的事件处理函数中被调用时，它是异步的。React会将多个`setState`的调用合并成一个批量更新，然后再一次性更新组件的状态，以此来提高性能。例如：

```js
handleClick() {
  this.setState({ count: this.state.count + 1 });
  this.setState({ count: this.state.count + 1 });
  this.setState({ count: this.state.count + 1 });
}
```

在这个例子中，当用户点击按钮时，`setState`会被连续调用三次。但是由于React会将这三次调用合并成一个批量更新，所以最终的结果是`count`值增加了3。

当`setState`是在React生命周期函数、`setTimeout`、`setInterval`等异步函数中被调用时，它是同步的。例如：

```js
componentDidMount() {
  this.setState({ count: this.state.count + 1 });
  console.log(this.state.count); // 输出0
}
```

在这个例子中，当组件挂载后，`setState`会被调用，但是由于是在生命周期函数中被调用，所以它是同步的。这时候`console.log`输出的是0，而不是1。 需要注意的是，无论`setState`是同步还是异步，它都是可靠的，因为React内部会确保更新后的状态会被正确地应用到组件上。但是在某些情况下，需要注意`setState`的同步异步性，以避免出现意外的行为。

## 81、React中useEeffect和useLayout的区别？

在React中，`useEffect`和`useLayoutEffect`都是React Hooks提供的用于处理副作用的函数，并且它们的作用和用法非常相似，但是它们之间存在一些区别。

1. 调用时机不同 `useEffect`会在浏览器渲染组件后，执行组件的所有更新操作之后调用，也就是说，它是在渲染周期的`commit`阶段执行的。 而`useLayoutEffect`会在浏览器渲染组件前，执行组件的所有更新操作之后调用，也就是说，它是在渲染周期的`commit`阶段之前执行的。
2. 是否会阻塞浏览器渲染 由于`useEffect`是在`commit`阶段执行的，所以它不会阻塞浏览器的渲染，因此如果你的副作用不需要同步更新UI，就可以使用`useEffect`。 而`useLayoutEffect`是在`commit`阶段之前执行的，所以它有可能会阻塞浏览器的渲染，因此如果你的副作用需要同步更新UI，就可以使用`useLayoutEffect`。
3. API用法相同 除了调用时机不同以外，`useEffect`和`useLayoutEffect`的使用方法是相同的。它们都接受两个参数：一个函数和一个可选的依赖数组，函数用于执行副作用操作，依赖数组用于控制副作用操作的执行时机。 综上所述，如果你的副作用不需要同步更新UI，就可以使用`useEffect`，它的性能更好，不会阻塞浏览器渲染；如果你的副作用需要同步更新UI，就可以使用`useLayoutEffect`，它会在浏览器渲染前执行，确保副作用操作会同步更新UI。

## 82、插槽有几种，分别是什么?

在React中，插槽可以通过`props.children`来实现，我们可以将一个组件作为另一个组件的子元素，从而实现插槽的效果。通常情况下，React中的插槽可以分为三种：

1. 基本插槽 基本插槽是将一个组件作为另一个组件的子元素传递，然后在父组件中通过`props.children`来获取子元素，从而实现插槽的效果。例如：

   ```js
   function Parent(props) {
     return (
       <div>
         <p>这是父组件的内容</p>
         {props.children}
       </div>
     );
   }
   function Child() {
     return (
       <div>
         <p>这是子组件的内容</p>
       </div>
     );
   }
   function App() {
     return (
       <Parent>
         <Child />
       </Parent>
     );
   }
   ```

   在这个例子中，`Child`组件是`Parent`组件的子元素，它会被渲染在`Parent`组件的内容中。

   \2. 包含插槽 包含插槽是将一个组件作为另一个组件的子元素传递，并且在子组件中使用`props.children`来渲染子元素，从而实现插槽的效果。例如：

   ```js
   function Parent(props) {
     return (
       <div>
         <Child>
           <p>这是父组件的内容</p>
         </Child>
       </div>
     );
   }
   function Child(props) {
     return (
       <div>
         <p>这是子组件的内容</p>
         {props.children}
       </div>
     );
   }
   function App() {
     return <Parent />;
   }
   ```

   在这个例子中，`Parent`组件将一个`<p>`标签作为`Child`组件的子元素传递，然后在`Child`组件中使用`props.children`来渲染子元素。

   \3. 具名插槽 具名插槽是将一个组件作为另一个组件的子元素传递，并且在子组件中使用特定的属性来渲染子元素，从而实现插槽的效果。例如：

   ```js
   function Parent(props) {
     return (
       <div>
         <Child header={<h1>这是父组件的标题</h1>} />
       </div>
     );
   }
   function Child(props) {
     return (
       <div>
         {props.header}
         <p>这是子组件的内容</p>
       </div>
     );
   }
   function App() {
     return <Parent />;
   }
   ```

   在这个例子中，`Parent`组件将一个`<h1>`标签作为`Child`组件的`header`属性传递，然后在`Child`组件中使用`props.header`来渲染子元素。

## 83、vue强制刷新组件的方式有哪些？

在Vue中，强制刷新一个组件的方式主要有以下几种：

1. 强制更新数据 通过修改组件的数据来触发组件的重新渲染，从而达到刷新组件的效果。在Vue中，可以使用`$forceUpdate`方法来强制更新组件的数据，例如：

   ```
   this.$forceUpdate();
   ```

   2.通过key来重渲染组件 在Vue中，当组件的`key`发生变化时，Vue会强制重新渲染组件。因此，可以通过修改组件的`key`属性来实现刷新组件的效果，例如：

   ```js
   <template>
     <div :key="componentKey">
       <!-- 组件内容 -->
     </div>
   </template>
   <script>
   export default {
     data() {
       return {
         componentKey: 0,
       };
     },
     methods: {
       refreshComponent() {
         this.componentKey += 1;
       },
     },
   };
   </script>
   ```

   在这个例子中，当调用`refreshComponent`方法时，会改变`componentKey`的值，从而触发组件重新渲染。

   \3. 使用`v-if`重新渲染组件 在Vue中，当`v-if`条件发生变化时，Vue会强制重新渲染组件。因此，可以通过修改`v-if`的条件来实现刷新组件的效果，例如：

   ```js
   <template>
     <div>
       <template v-if="showComponent">
         <!-- 组件内容 -->
       </template>
     </div>
   </template>
   <script>
   export default {
     data() {
       return {
         showComponent: true,
       };
     },
     methods: {
       refreshComponent() {
         this.showComponent = false;
         this.$nextTick(() => {
           this.showComponent = true;
         });
       },
     },
   };
   </script>
   ```

   在这个例子中，当调用`refreshComponent`方法时，会先将`showComponent`的值设置为`false`，然后在下一个`tick`中将其设置为`true`，从而触发组件重新渲染。

   

## 84、nextTick的作用是什么？

`			nextTick`是Vue.js中一个重要的异步API，它的作用是在DOM更新之后执行延迟回调。在Vue.js中，当数据发生改变时，Vue.js并不会立即更新DOM，而是开启一个异步队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个数据在同一个事件循环中发生多次改变，Vue.js会合并它们，并且只执行一次DOM更新。当所有的同步任务完成之后，Vue.js会在下一个tick中清空异步队列，并执行其中的回调函数，这个时候DOM已经更新完毕。

​		`nextTick`就是在DOM更新完毕之后，执行延迟回调函数的API。在Vue.js中，我们常常需要在DOM更新之后执行一些操作，例如获取更新后的DOM尺寸、滚动条位置等等。如果我们直接在数据发生改变之后执行这些操作，可能会获取到错误的结果。因此，我们需要在DOM更新之后再执行这些操作，而`nextTick`就提供了这样的功能。 `nextTick`的使用非常简单，只需要在Vue实例上调用`$nextTick`方法，并传入一个回调函数即可。例如：

```
this.$nextTick(() => {
  // DOM更新之后执行的操作
});
```

在这个例子中，回调函数会在DOM更新之后被执行，从而保证了获取到正确的DOM尺寸、滚动条位置等信息。 需要注意的是，`nextTick`并不是一个立即执行的方法，它是一个异步方法，因此回调函数不会立即被执行。如果需要立即执行回调函数，可以将它放在`nextTick`之前执行。另外，`nextTick`方法是一个实例方法，只能在Vue实例中使用，不能在全局范围内直接调用。

## 85、vue2中的data为啥必须是个函数，要有返回值？

在Vue 2.x中，组件的`data`选项必须是一个返回对象的函数，而不是直接一个对象。这是因为Vue在创建组件实例时，会将组件的选项进行合并，如果`data`选项直接是一个对象，那么所有组件的`data`选项都会指向同一个对象，这就会导致一个组件的数据改变会影响到其他组件的数据，这是不合理的。 因此，Vue 2.x中规定`data`选项必须是一个返回对象的函数，每个组件实例都会调用该函数返回一个独立的数据对象。这样就保证了每个组件实例都有自己独立的数据对象，互不干扰。

举个例子，如果`data`是一个普通的对象：

```js
const data = {
  count: 0
};
Vue.component('my-component', {
  data: data,
  template: '<div>{{ count }}</div>'
});
new Vue({
  el: '#app'
});
```

那么所有的`my-component`组件实例都会共享同一个`data`对象，这就会导致一个组件的数据改变会影响到其他组件的数据：

```js
data.count = 1; // 所有组件实例的数据都被改变了
```

如果`data`是一个返回对象的函数：

```js
Vue.component('my-component', {
  data() {
    return {
      count: 0
    };
  },
  template: '<div>{{ count }}</div>'
});
new Vue({
  el: '#app'
});
```

那么每个`my-component`组件实例都会调用`data`函数，返回一个独立的数据对象，这样就保证了每个组件实例都有自己独立的数据对象，互不干扰：

```js
const myComponent1 = new Vue({
  el: '#my-component1'
});
const myComponent2 = new Vue({
  el: '#my-component2'
});
myComponent1.$data.count = 1; // 只有myComponent1实例的数据被改变了
```

因此，Vue 2.x中要求`data`选项必须是一个返回对象的函数，这样可以避免组件之间数据共享导致的问题。

## 86、v-if和v-show的区别？

`v-if`和`v-show`都是Vue.js中的条件渲染指令。 `v-if`的作用是根据表达式的值的真假来有条件地渲染元素。当表达式的值为`true`时，元素被渲染；当表达式的值为`false`时，元素被移除。因此，当条件不满足时，`v-if`可以减少不必要的DOM操作，提高渲染性能。

 `v-show`的作用和`v-if`类似，也是根据表达式的值的真假来有条件地显示或隐藏元素。不同的是，当表达式的值为`false`时，元素并没有被移除，而是通过设置`display`属性来隐藏元素。因此，当条件改变频繁时，`v-show`比`v-if`更加适用，因为切换`display`属性的开销比插入/删除元素的开销小。 总之，`v-if`适用于条件不经常改变的情况，可以减少不必要的DOM操作，提高渲染性能；`v-show`适用于条件经常改变的情况，可以通过切换`display`属性来减少DOM操作，提高渲染性能。

## 87、组件通信中子改父的方法有哪些？

子组件向父组件通信可以通过以下方法：

1. props：父组件可以通过props传递数据给子组件，在子组件中通过事件等方式将数据传递回父组件。
2. $emit：子组件可以通过$emit触发一个自定义事件，并传递数据给父组件，父组件可以通过监听该事件来获取数据。
3. $parent：子组件可以通过$parent属性访问父组件实例，从而调用父组件中的方法。
4. $refs：父组件可以通过$refs获取子组件的实例，从而调用子组件中的方法。
5. Vuex：如果应用使用了Vuex状态管理库，子组件可以通过dispatch一个action来改变父组件的状态。 需要注意的是，直接修改父组件中的数据是不被Vue所推荐的，因为这会造成数据的不可预测性和追踪性的下降。如果需要修改父组件中的数据，可以通过父组件传递一个方法给子组件，然后在子组件中调用该方法来修改父组件中的数据。

## 88、vue动态路由的具体方案和过程？

Vue动态路由是指根据不同的参数动态生成路由的过程。实现动态路由的具体方案和过程如下：

1、在路由配置文件中定义动态路由，例如：

```
{
  path: '/user/:id',
  component: User
}
```

在组件中通过$route.params获取动态参数，例如：

```
export default {
  props: {
    id: {
      type: Number,
      required: true
    }
  },
  mounted () {
    console.log(this.id)
  }
}
```

3、动态生成路由。通过Vue Router提供的router.addRoutes()方法动态添加路由，例如：

```
router.addRoutes([
  {
    path: '/user/:id',
    component: User
  }
])
```

4、使用动态路由。在应用中通过router.push()方法跳转到动态路由，例如：

```
router.push('/user/' + id)
```

以上是Vue动态路由的基本方案和过程，需要注意的是，动态路由的参数不能以$开头，因为$是Vue内部保留的字符。此外，动态路由的参数可以通过props或者$route.params在组件中获取，但是推荐使用props来获取参数，因为这样更符合Vue的单向数据流的设计原则。

## 89、什么叫深浅拷贝？区别是什么？

深浅拷贝是指在JavaScript中复制一个对象时，是否复制其内部的子对象。深拷贝会复制整个对象，包括其内部的子对象，而浅拷贝只会复制对象本身，而不会复制其内部的子对象。 具体来说，深拷贝会创建一个新的对象，包括其内部的子对象，新的对象和原来的对象没有任何关联。而浅拷贝只会复制对象本身，如果对象内部有子对象，那么新的对象和原来的对象会共享子对象，也就是说，新的对象和原来的对象内部的子对象是同一个对象。 深拷贝和浅拷贝的区别在于对于子对象的处理方式不同。深拷贝会递归的复制整个对象，包括其内部的子对象，而浅拷贝只会复制对象本身，只是增加了一个指向子对象的引用。因此，在修改子对象时，深拷贝和浅拷贝的表现也会不同。 需要注意的是，由于深拷贝会递归的复制整个对象，因此会比浅拷贝更加耗时和占用内存。在处理大型对象时，应该尽量使用浅拷贝来减少内存占用和提高性能。

## 90、什么是微任务什么是宏任务，promise是微任务还是宏任务？

在JavaScript中，任务分为两种类型：宏任务和微任务。宏任务是指在主线程上排队的任务，例如DOM事件、setTimeout、setInterval等。而微任务是指需要在当前任务执行结束后立即执行的任务，例如Promise的回调、MutationObserver等。 Promise中的then/catch/finally回调函数是微任务，它们会在当前任务执行完毕后立即执行。这是因为Promise是异步操作，当异步操作完成后，会把对应的回调函数推入微任务队列中，等待主线程空闲时立即执行，以便及时更新页面或执行下一步操作。 需要注意的是，Promise的回调函数虽然是微任务，但是Promise本身是在主线程中执行的宏任务。当执行到Promise时，实际上是把Promise的回调函数推入微任务队列，Promise本身在主线程中继续执行。当所有的宏任务执行完毕后，主线程会检查微任务队列是否为空，如果不为空，则依次执行微任务。

## 91、前端实现性能优化的方法有哪些？

前端实现性能优化的方法有很多，以下列举几个常见的方法：

1. 减少HTTP请求。将CSS、JS、图片等静态资源合并、压缩，减少HTTP请求次数，提高页面加载速度。
2. 使用CDN。将静态资源存放在CDN上，提高资源的访问速度。
3. 压缩资源。将CSS、JS、图片等静态资源进行压缩，减小文件大小，提高资源加载速度。
4. 使用缓存。合理使用浏览器缓存和HTTP缓存，减少重复请求，提高访问速度。
5. 懒加载。对于图片等资源，可以使用懒加载的方式，当用户滚动到相关区域时再加载图片，减少页面加载时间。
6. 减少DOM操作。DOM操作是非常耗费性能的操作，应该尽量减少DOM操作的次数。
7. 减少重绘和重排。重绘和重排会导致页面重新渲染，影响性能，可以通过CSS的优化来减少重绘和重排。
8. 代码优化。对代码进行优化，如去掉不必要的注释、空格等，可以减少文件大小，提高代码执行速度。
9. 使用Web Worker。Web Worker可以将一些耗时的任务放在后台线程中执行，不会阻塞主线程，提高性能。 总之，前端性能优化需要综合考虑各方面因素，针对具体的问题进行优化。
10. 前端ui组件库采取按需加载的方式引入

## 92、改变数组的方法有哪些？非变异的方法有哪些？？

改变数组的方法主要有以下几种：

1. push()：在数组末尾添加一个或多个元素，返回新数组的长度。
2. pop()：删除数组末尾的元素，返回被删除的元素。
3. shift()：删除数组第一个元素，返回被删除的元素。
4. unshift()：在数组开头添加一个或多个元素，返回新数组的长度。
5. splice()：删除从指定位置开始的零个或多个元素，并插入新的元素，返回被删除的元素。
6. sort()：对数组元素进行排序，返回排序后的数组。
7. reverse()：颠倒数组中元素的顺序，返回颠倒后的数组。
8. fill()：用一个固定值填充数组中从起始索引到终止索引内的全部元素，返回修改后的数组。
9. copyWithin()：将数组内一段元素复制到另一段位置上，返回修改后的数组。 
10. 非变异的数组方法主要有以下几种：
11. concat()：连接两个或多个数组，返回新数组。
12. join()：将数组中所有元素转换为字符串并连接起来，返回字符串。
13. slice()：从指定的开始索引到结束索引截取数组，返回新数组。
14. filter()：创建一个新数组，其中包含通过指定函数测试的所有元素。
15. map()：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
16. reduce()：将数组中的元素通过一个函数累加为一个值。
17. every()：测试数组的所有元素是否都通过指定函数的测试。
18. some()：测试数组中是否至少有一个元素通过指定函数的测试。 需要注意的是，非变异的数组方法不会修改原数组，而是返回一个新的数组或其他类型的值。

## 93、原型和原型链的区别？

原型是JavaScript中的一个概念，它是每个对象都具有的一个属性，用于存储对象的共享属性和方法。每个对象都有一个原型对象，可以通过 `__proto__` 属性访问，原型对象上的属性和方法可以被对象本身访问和使用。 原型链是一种机制，用于查找对象的属性和方法。当一个对象需要访问一个属性或方法时，如果该对象本身没有该属性或方法，就会去该对象的原型对象上查找，如果原型对象上也没有，则会继续去原型对象的原型对象上查找，直到找到该属性或方法为止，这就是原型链。 简单来说，原型是每个对象都有的一个属性，用于存储共享属性和方法，而原型链是一种查找机制，用于查找对象的属性和方法。原型对象通过原型链与对象相互关联，形成了一条链式结构，使得对象可以访问到原型对象上的属性和方法。

## 94、什么强缓存和弱缓存？

​	强缓存和弱缓存都是浏览器缓存的两种机制。 强缓存是指浏览器在请求资源时，直接从本地缓存中获取资源，而不去服务器端验证资源是否有更新，这样可以有效减少网络请求，提高页面加载速度。强缓存可以通过设置HTTP响应头中的 `Expires` 和 `Cache-Control` 字段来实现，`Expires` 是一个绝对时间，表示缓存资源的过期时间，而 `Cache-Control` 是一个相对时间，表示缓存资源的最大有效时间，两者都可以用来控制强缓存。 

​	弱缓存是指浏览器在请求资源时，会向服务器端发送一个请求，由服务器端决定是否从缓存中获取资源，如果资源没有更新，则返回304状态码，告诉浏览器直接从本地缓存中获取资源。弱缓存可以通过设置HTTP响应头中的 `Last-Modified` 和 `If-Modified-Since` 字段来实现，`Last-Modified` 表示资源的最后修改时间，`If-Modified-Since` 表示上次请求资源时返回的 `Last-Modified` 值，当请求资源时，可以将 `If-Modified-Since` 值通过请求头发送给服务器端，服务器端可以根据这个值判断资源是否更新，如果没有更新，则返回304状态码。 需要注意的是，弱缓存会发送一次请求，因此相对于强缓存而言，会增加一定的网络开销。两种缓存机制都有各自的优缺点，需要根据具体情况选择合适的缓存策略。

## 95、forEach和Map的区别？

`forEach` 和 `Map` 都是 JavaScript 中常用的数组迭代方法，它们的主要区别在于返回值和使用方式：

1. 返回值：`forEach` 方法没有返回值，而 `Map` 方法会返回一个新的数组。

2. 使用方式：`forEach` 方法用于遍历数组中的每个元素，对每个元素执行提供的回调函数，没有返回值；而 `Map` 方法用于对数组中的每个元素执行提供的回调函数，并返回一个新的数组，新数组中的元素是回调函数的返回值。 具体来说，`forEach` 方法的语法如下：

   ```
   array.forEach(function(currentValue, index, array) {
     // 回调函数
   }, thisValue);
   ```

   其中，`currentValue` 表示当前元素的值，`index` 表示当前元素的索引，`array` 表示当前数组，`thisValue` 表示回调函数中 `this` 的值。`forEach` 方法会依次遍历数组中的每个元素，并对每个元素执行提供的回调函数。 

   `Map` 方法的语法如下：

   ```
   var new_array = array.map(function(currentValue, index, array) {
     // 回调函数
   }, thisValue);
   ```

   其中，`currentValue` 表示当前元素的值，`index` 表示当前元素的索引，`array` 表示当前数组，`thisValue` 表示回调函数中 `this` 的值。`Map` 方法会依次遍历数组中的每个元素，并对每个元素执行提供的回调函数，将回调函数的返回值组成一个新的数组并返回。 因此，如果需要对数组中的每个元素执行某个操作，而不需要返回新的数组，可以使用 `forEach` 方法；如果需要对数组中的每个元素执行某个操作，并将操作的结果组成一个新的数组返回，可以使用 `Map` 方法。

## 96、http状态码有哪些？

HTTP 状态码是用来表示 Web 服务器和客户端请求之间的响应状态的代码，它由三位数字组成，第一位数字定义了响应的类别，后两位数字没有分类的作用。常见的 HTTP 状态码如下：

- 1xx：信息性状态码，表示服务器已接收到请求，需要客户端继续操作。
- 2xx：成功状态码，表示服务器已成功接收到请求并处理完成。
- 3xx：重定向状态码，表示客户端需要进一步操作才能完成请求。
- 4xx：客户端错误状态码，表示客户端发送的请求有错误。
- 5xx：服务器错误状态码，表示服务器不能够正常处理请求。 具体的状态码包括：
- 100 Continue：表示客户端请求的情况下，服务器已接收到请求头，并且将继续等待请求体。
- 200 OK：表示请求成功，服务器已经正确处理并返回请求内容。
- 204 No Content：表示请求成功，但服务器没有返回任何内容。
- 301 Moved Permanently：表示被请求的资源已永久移动到新位置。
- 302 Found：表示被请求的资源已临时移动到新位置。
- 304 Not Modified：表示客户端已经执行了 GET 请求，但文件未被修改。
- 400 Bad Request：表示客户端请求有语法错误或请求参数错误。
- 401 Unauthorized：表示客户端请求需要身份验证，但客户端未提供有效身份验证凭据。
- 403 Forbidden：表示服务器拒绝执行请求。
- 404 Not Found：表示请求的资源不存在。
- 500 Internal Server Error：表示服务器端发生了错误，无法完成请求处理。
- 502 Bad Gateway：表示服务器作为网关或代理，从上游服务器收到无效响应。
- 503 Service Unavailable：表示服务器暂时无法处理请求，通常由于维护或过载导致。 以上是常见的 HTTP 状态码，不同的状态码代表着不同的响应结果，可以用来帮助开发人员诊断和解决问题。

## 97、什么是TCP和UDP?

TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）都是互联网协议（Internet Protocol）中的两个重要的传输层协议。 TCP 是一种面向连接的协议，提供可靠的数据传输服务，通过三次握手建立连接，保证数据的完整性、顺序性和可靠性，适用于数据量大、可靠性要求高的应用场景，如 HTTP、FTP 等。 UDP 是一种无连接的协议，不保证数据传输的可靠性，适用于数据量小、实时性要求高的应用场景，如视频会议、实时游戏等。UDP 没有建立连接的过程，也不对数据包进行确认和重传，因此传输速度快，但传输的数据可能会出现丢失、重复和乱序等问题。 区别：

- 连接方式：TCP 是面向连接的，UDP 是无连接的。
- 数据传输可靠性：TCP 保证数据传输的可靠性，UDP 不保证。
- 建立连接：TCP 通过三次握手建立连接，UDP 不需要建立连接。
- 数据包大小：TCP 的数据包大小有限制，UDP 的数据包大小没有限制。
- 传输效率：UDP 传输效率高于 TCP。
- 应用场景：
- TCP 适用于数据量大、可靠性要求高的应用场景，如 HTTP、FTP 等；UDP 适用于数据量小、实时性要求高的应用场景，如视频会议、实时游戏等。 总之，TCP 和 UDP 有各自的优缺点和适用场景，开发人员应根据具体的应用场景选择合适的传输协议。

## 98、什么是重绘和重排？

​		重绘（Repaint）和重排（Reflow）是指浏览器渲染页面时的两个重要过程。

 		重绘是指当元素样式的改变不影响布局时，浏览器会将元素的新样式重新绘制到页面上，但不会改变元素在页面中的位置和大小。 

​		重排是指当元素的尺寸、位置、内容发生变化时，浏览器需要重新计算元素在页面中的位置和大小，并将其重新布局，这个过程称为重排。 

​		重排和重绘的触发原因包括：页面首次渲染、浏览器窗口大小发生改变、元素的位置、大小、内容、样式发生改变、用户与页面交互等。 重排和重绘的开销比较大，会影响页面的性能，因此需要尽量减少它们的发生次数。可以通过以下方法来减少重排和重绘的次数：

- 使用 CSS3 的 transform 属性，而不是常规的 top、left 属性来移动元素。
- 避免使用 table 布局，因为 table 中的元素往往需要多次计算才能确定其位置和大小，从而增加重排的次数。
- 使用虚拟 DOM，避免频繁操作真实 DOM，减少重排和重绘的次数。
- 使用 requestAnimationFrame 方法，将多个重排和重绘的操作合并成一次执行，提高性能。 总之，重排和重绘是浏览器渲染页面时的两个重要过程，开发人员需要了解其原理和影响因素，尽量减少其发生次数，提高页面的性能。

## 99、什么BFC？

BFC（Block Formatting Context）是块级格式化上下文的缩写，是 Web 页面中的一种 CSS 渲染模式，用于控制块级盒子的布局和浮动元素的交互。 BFC 可以看作是一个独立的渲染区域，其中的元素布局是相互独立的，不会影响到外部元素的布局。BFC 具有以下特性：

1. 内部的 Box 会在垂直方向，一个接一个地放置。
2. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。
3. 每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。
4. BFC 的区域不会与 float box 重叠。
5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面元素，反之也是如此。
6. 计算 BFC 的高度时，浮动元素也参与计算。 通常可以通过以下方式来创建 BFC：

- 根元素或包含根元素的元素。
- 浮动元素（float 不为 none）。
- 绝对定位元素（position 为 absolute 或 fixed）。
- display 值为 inline-block、table-cell、table-caption 或 inline-flex 的元素。
- overflow 值不为 visible 的块级盒子。 利用 BFC 特性的一些常见应用场景包括：
- 清除浮动（清除浮动的原理就是利用 BFC 包含浮动元素）。
- 避免 margin 重叠。
- 自适应两栏布局。
- 防止文字环绕。 总之，BFC 是一种 CSS 渲染模式，用于控制块级盒子的布局和浮动元素的交互。了解 BFC 的特性和应用场景有助于提高页面布局的灵活性和可靠性。

## 100、什么是柯里化和反柯里化？

柯里化（Currying）是一种将接受多个参数的函数转换为接受一个单一参数的函数，并且返回接受余下参数且返回结果的新函数的技术。换句话说，柯里化是将一个多参数函数转换为一系列单参数函数的过程。 柯里化的主要作用是简化函数的调用方式和参数传递的方式。通过柯里化能够使函数的参数更加灵活，便于组合和复用。在 JavaScript 中，可以使用 bind() 方法和闭包来实现柯里化。 

反柯里化（Uncurrying）是指将一个已经经过柯里化的函数恢复为一个普通的多参数函数的过程。反柯里化的主要作用是扩展函数的功能和增强函数的灵活性。在 JavaScript 中，可以使用 call() 和 apply() 方法来实现反柯里化。 柯里化和反柯里化都是一种函数的转换技术，它们可以使函数的调用方式更加灵活和方便，有助于提高代码的可读性和可维护性。在实际开发中，可以根据需要使用柯里化和反柯里化来进行函数的转换和扩展。

## 101、doucument.ready和window.onload的区别是什么？

document.ready 和 window.onload 都是 JavaScript 中常用的页面加载完成后执行代码的方法，但它们有一些不同的特点和应用场景。 document.ready 是 jQuery 提供的方法，它是在 DOM 树结构就绪后执行的，即 DOMContentLoaded 事件触发后立即执行，不必等到所有资源都加载完成。这意味着，当页面的 DOM 结构加载完成后，就可以使用 jQuery 来操作页面元素，而不必等到其他资源（如图片、样式等）加载完成。相比之下，document.ready 的执行速度更快，用户体验更好。此外，document.ready 可以同时绑定多个事件，可以在一个函数中执行多个操作。

 window.onload 是在页面所有资源（如图片、样式等）都加载完成后执行的，包括 DOM、样式表、图片、flash 等。这意味着，当页面上的所有资源都加载完成后，才可以进行一些需要依赖这些资源的操作，如获取图片的宽高等。相比之下，window.onload 的执行速度较慢，用户体验较差。此外，window.onload 只能绑定一个事件，只能在一个函数中执行一个操作。 因此，document.ready 和 window.onload 适用的场景不同。如果需要在页面 DOM 结构就绪后立即执行一些操作，可以使用 document.ready；如果需要在页面所有资源都加载完成后才执行操作，可以使用 window.onload。如果需要同时使用这两种方法，可以将 document.ready 作为 window.onload 的回调函数执行。

## 102、长链接，短链接，轮询？

长链接（Long Polling）是一种实现服务器与客户端实时通信的技术，它通过向服务器发送一次长时间的请求并保持请求连接不断开来实现实时通信的目的。长链接的主要特点是实时性好，但是会占用服务器资源和带宽，同时容易受到网络环境的影响。 

短链接（Short Polling）是一种常见的客户端与服务器通信方式，它通过客户端定时向服务器发送请求来获取最新数据，然后将数据展示到页面上。短链接的主要特点是实现简单，但是会导致频繁的网络请求，增加服务器压力和响应时间，同时实时性较差。

 轮询（Polling）是一种客户端与服务器通信的方式，它通过客户端定时向服务器发送请求，获取最新数据并更新页面。轮询的主要特点是实现简单，但是会导致频繁的网络请求，增加服务器压力和响应时间，同时实时性较差。 

总的来说，长链接、短链接和轮询都是实现客户端与服务器通信的方式，它们各有优缺点，适用于不同的场景和需求。在实际应用中，需要根据具体的业务需求和技术实现来选择合适的通信方式。

## 103、react中 class类组件和函数组件的区别？

React 中有两种主要的组件类型：类组件和函数组件。 类组件是使用 ES6 class 语法定义的组件，它们是 React 中最常用的组件类型。类组件必须继承 React.Component 类，并且必须实现 render 方法来渲染组件。类组件可以使用 state 和 props 来存储和传递数据，并且可以使用生命周期方法来处理组件的生命周期事件。类组件通常用于实现复杂的 UI 界面和业务逻辑。 

函数组件是使用函数定义的组件，它们是 React 中较新的组件类型，从 React 16.8 版本开始引入了 Hooks 来支持函数组件。函数组件通常比类组件更加简洁和易于维护，因为它们没有类组件中的 this 和生命周期方法，可以避免一些常见的错误。函数组件可以接收 props 作为参数，并且可以使用 Hooks 来实现状态管理和生命周期处理。 

类组件和函数组件的主要区别在于语法和使用方式。类组件使用 ES6 class 语法定义，而函数组件使用函数定义。类组件可以使用 state 和生命周期方法来处理组件的状态和生命周期事件，而函数组件可以使用 Hooks 来实现相同的功能。在实际开发中，可以根据具体的业务需求和技术选型来选择类组件或函数组件。

## 104、this.setState是同步还是异步？

在 React 中，this.setState 方法是异步更新组件状态的。这意味着，当调用 this.setState 方法更新组件状态时，React 并不会立即更新状态，而是将更新请求加入到一个更新队列中，等待后续处理。在此期间，React 可以对多个更新请求进行批处理和优化，以提高性能和减少不必要的渲染。 由于 this.setState 方法是异步的，因此不能在调用该方法后立即读取更新后的状态。如果需要在更新后立即读取状态，可以使用 setState 的第二个参数，该参数为一个回调函数，它会在状态更新后被调用，并且会传递更新后的状态和更新前的属性值。例如：

```
this.setState({ count: this.state.count + 1 }, () => {
  console.log(this.state.count); // 输出更新后的状态值
});
```

需要注意的是，虽然 this.setState 方法是异步的，但是在 React 的合成事件和生命周期方法中，它会被自动批量更新，以提高性能和减少不必要的渲染。因此，在这些情况下，可以放心地使用 this.setState 方法，而不必担心性能问题。

## 105、diff算法？

Diff 算法是 React 用来计算 Virtual DOM 差异的一种高效算法。它通过比较新旧 Virtual DOM 树的差异，仅更新需要修改的部分，从而避免了全量更新，提高了应用性能。 Diff 算法的核心思想是同层比较和差异最小化。 同层比较指的是在比较新旧 Virtual DOM 树时，只会对同一层级的节点进行比较，不会跨层级比较。这样可以避免很多无意义的比较，提高比较效率。 差异最小化指的是在比较新旧 Virtual DOM 树时，只会比较不同的部分，而不会比较相同的部分。比较的过程中，React 会为每个节点分配唯一的 key 值，以便进行高效的比较和更新。 Diff 算法的具体实现过程包括以下几个步骤：

1. 首先比较根节点，如果根节点不同，则直接替换整个树。
2. 如果根节点相同，则比较子节点。React 会遍历每个子节点，并比较它们的类型、属性和子节点等信息。
3. 如果子节点都相同，则直接返回，不需要更新。
4. 如果子节点不同，则分情况讨论： a. 如果节点类型不同，则直接替换整个节点及其子树。 b. 如果节点类型相同但属性不同，则更新节点的属性。 c. 如果节点类型相同且属性相同，则继续比较子节点。
5. 在比较子节点时，React 会使用同层比较和差异最小化的策略，避免无意义的比较和更新。 通过使用 Diff 算法，React 可以极大地提高应用的性能和响应速度，同时保证了组件的正确性和可维护性。

## 106、JavaScript和typescript的区别？

JavaScript和TypeScript的主要区别如下：

1. JavaScript是一种动态类型语言，而TypeScript是一种静态类型语言。这意味着在JavaScript中，变量不需要事先声明类型，而在TypeScript中，变量需要声明类型。
2. TypeScript具有更强的类型检查和编译时错误检查，可以更早地捕获代码错误。
3. TypeScript支持类、接口和模块等面向对象编程的概念，而JavaScript则不支持这些概念。
4. TypeScript可以编译为JavaScript，因此可以在任何支持JavaScript的地方运行，而JavaScript无法编译为TypeScript。
5. TypeScript具有更好的可维护性和可读性，因为它具有更多的语法结构和类型检查。 总之，TypeScript是JavaScript的超集，提供了更多的功能和类型检查，但在一些情况下可能会增加代码量和开发时间。

## 107、ts类型约束的理解？

TypeScript是一种静态类型语言，它可以帮助开发者在编码的过程中发现类型错误。而类型约束是TypeScript中最重要的概念之一，它可以帮助开发者限制变量、函数、类等的数据类型，从而避免不必要的类型错误。 在TypeScript中，类型约束可以通过声明变量、函数、类等时指定类型来实现。例如：

```
//声明变量时指定类型
let num: number = 10;
//声明函数时指定参数类型和返回值类型
function add(a: number, b: number): number {
  return a + b;
}
//声明类时指定属性类型和方法返回值类型
class Person {
  name: string;
  age: number;
  getAge(): number {
    return this.age;
  }
}
```

在以上的例子中，我们分别声明了一个number类型的变量、一个接收两个number类型参数并返回number类型的函数，以及一个包含两个string和number类型属性以及一个返回number类型的方法的Person类。这些类型约束可以帮助我们在编码过程中限制变量、函数和类的数据类型，从而使代码更加健壮和可维护。 需要注意的是，类型约束只在TypeScript编译期间有效，在运行时会被移除。这意味着在TypeScript代码被编译为JavaScript后，类型约束会被移除掉，因此在运行时就不能再保证类型的正确性了。

## 108、什么是泛型，枚举类型，接口类型？

泛型、枚举类型和接口类型是TypeScript中的三个重要概念。

1. 泛型 泛型是指在编写函数、类或接口时，不预先指定具体的类型，而是在使用时再指定类型的一种特性。泛型可以增加代码的灵活性和复用性，适用于需要处理多种类型数据的情况。例如：

   ```tsx
   function identity<T>(arg: T): T {
     return arg;
   }
   let output = identity<string>("hello world"); // output的类型为string
   ```

   在以上例子中，我们定义了一个泛型函数identity，它接收一个类型为T的参数arg，并将arg的类型作为返回值返回。在使用identity函数时，我们指定T的类型为string，因此output的类型也为string。 2. 枚举类型 枚举类型是指一种特殊的数据类型，它用于定义一组有名字的常量。枚举类型可以帮助开发者在代码中使用更具有可读性和可维护性的常量。例如：

   ```ts
   enum Color {
     Red = 1,
     Green = 2,
     Blue = 3
   }
   let color: Color = Color.Red; // color的值为1
   ```

   在以上例子中，我们定义了一个名为Color的枚举类型，它包含三个常量：Red、Green和Blue。这些常量的值分别为1、2和3。在使用Color类型时，我们可以将color的值设置为Color.Red，它的值就是1。

   \3. 接口类型 接口类型是指一种用于描述对象的结构的类型。接口类型可以定义对象的属性、方法、索引等，从而使开发者在编写代码时可以对对象的结构进行更精确的类型检查。例如：

   ```ts
   interface Person {
     name: string;
     age: number;
     sayHello(): void;
   }
   function greeter(person: Person) {
     console.log("Hello, " + person.name);
   }
   let user = { name: "Tom", age: 18, sayHello() { console.log("Hello"); } };
   greeter(user);
   ```

   在以上例子中，我们定义了一个Person接口，它包含三个属性：name、age和sayHello方法。在greeter函数中，我们接收一个类型为Person的参数person，并使用person的name属性输出一句问候语。在调用greeter函数时，我们传入一个对象user，它的类型满足Person接口的要求，因此代码可以正常运行。

## 109、输入url地址发生了什么？

在输入URL地址后，浏览器会执行以下步骤：

1. URL解析：浏览器将输入的URL地址解析成协议、主机名、端口号、路径、查询参数等各个组成部分，以便后续的请求操作。
2. DNS解析：浏览器会尝试在本地缓存中查找该域名的IP地址，如果没有找到，则向本地DNS服务器发送DNS解析请求。如果本地DNS服务器还没有缓存该域名的IP地址，则会向根域名服务器发起请求，逐级向下查找，直到找到该域名对应的IP地址为止。
3. 建立TCP连接：浏览器通过IP地址和端口号向服务器发起TCP连接请求，经过三次握手建立起连接。
4. 发送HTTP请求：浏览器向服务器发送HTTP请求消息，包括请求方法、请求头、请求体等信息。
5. 服务器响应：服务器接收到请求消息后，会根据请求内容做出相应的响应，包括响应头、响应状态码、响应内容等信息。
6. 接收响应内容：浏览器接收到响应消息后，根据响应头信息判断是否有缓存可用，若无则将响应内容进行解析，并根据响应类型进行相应的处理，最终将结果显示在页面上。
7. 断开TCP连接：浏览器在处理完响应消息后，向服务器发送断开TCP连接的请求，经过四次挥手断开连接。 以上就是浏览器在输入URL地址后发生的主要步骤，它们共同组成了HTTP协议中的请求-响应模型。

## 110、less和sass的区别？

Less和Sass都是CSS预处理器，它们都可以增强CSS的编写效率和可维护性，但它们也有一些区别：

1. 语法不同：Less使用类似CSS的语法，而Sass使用的是缩进式语法。Less在CSS的基础上进行了扩展，使得学习成本较低，上手比较容易；而Sass的语法更加简洁明了，例如省略了分号和大括号，让代码更加简洁。
2. 变量的作用域：Less中的变量作用域只在定义它的代码块内有效，而Sass中的变量在整个文件里都有效，可以跨越代码块使用。
3. Mixin的实现方式不同：在Less中，Mixin使用的是@Mixin语句，而在Sass中，Mixin使用的是@include语句。在使用时，Less需要在Mixin后面添加参数，而Sass不需要。
4. 函数的支持：Sass支持函数的定义和使用，可以使用内置函数或自定义函数，而Less不支持函数的定义，只提供了一些内置函数供使用。
5. 扩展机制不同：Sass中的@extend指令可以让一个选择器继承另一个选择器的样式，而Less中的扩展机制使用的是:extend()函数。 总的来说，Less和Sass都是非常优秀的CSS预处理器，它们的使用都能够提高CSS编写的效率和可维护性。选择哪一个预处理器主要取决于个人的喜好和项目需求。

## 111、git常用的指令以及含义？

1. `git init`: 在当前目录初始化一个新的 Git 仓库。
2. `git clone`: 克隆一个远程 Git 仓库到本地。
3. `git add`: 将修改后的文件添加到暂存区。
4. `git commit`: 将暂存区的文件提交到本地仓库。
5. `git push`: 将本地仓库推送到远程仓库。
6. `git pull`: 拉取远程仓库最新的代码到本地。
7. `git status`: 查看当前 Git 仓库的状态。
8. `git log`: 查看提交历史记录。
9. `git branch`: 查看所有分支。
10. `git checkout`: 切换分支或者回滚到某个提交版本。
11. `git merge`: 将一个分支合并到当前分支。
12. `git stash`: 保存当前工作进度，以便以后恢复。
13. `git reset`: 撤销某个提交。
14. `git remote`: 查看和管理远程仓库。
15. `git tag`: 给某个提交打上标签，用于发布版本。

## 112、ES6set和map？

ES6中提供了Set和Map两种数据结构，它们分别用于存储唯一的值和键值对集合。

`Set`是一个类似于数组的数据结构，但是它的成员唯一，没有重复的值

```js
let set = new Set([1, 2, 3, 3, 4, 5]);
console.log(set); // Set {1, 2, 3, 4, 5}
set.add(6);
set.delete(1);
console.log(set.has(2)); // true
set.forEach(item => console.log(item));
```

`Map`是一种键值对的集合，类似于对象。但是，Map的键可以是任意类型的，而对象的键只能是字符串类型。

```js
let map = new Map();
map.set('name', 'Tom');
map.set('age', 18);
map.set('gender', 'male');
console.log(map.get('name')); // Tom
map.forEach((value, key) => {
  console.log(key + ':' + value);
});
```

Set和Map都可以使用`for...of`进行遍历，也可以使用`forEach`方法进行遍历。Set和Map都提供了`size`属性来获取元素个数。

## 113、useEffect和useLayout的区别？

`useEffect`和`useLayoutEffect`都是React提供的用于处理副作用的hook，但它们的执行时机不同，主要区别在于更新前和更新后的时机不同。

- `useEffect`会在组件渲染完成后执行，也就是在DOM渲染完成后执行。它会在每次组件更新时都会执行。因此，`useEffect`中的操作是异步执行的。
- `useLayoutEffect`会在组件渲染完成后，DOM更新前执行。它会在每次组件更新时都会执行。因此，它的执行是同步的，它会阻塞组件的渲染，直到它的回调函数执行完毕。 通常情况下，我们都应该优先使用`useEffect`，只有在需要同步执行操作时，才使用`useLayoutEffect`。例如，当我们需要在渲染之前测量DOM元素的大小和位置时，就可以使用`useLayoutEffect`来确保测量结果的准确性。 另外需要注意的是，由于`useLayoutEffect`会阻塞渲染，因此它可能会对性能产生一定的影响。如果你只需要在DOM渲染之后执行一些操作，而不需要阻塞渲染，那么应该使用`useEffect`来代替`useLayoutEffect`。

## 114、开发中搜索，排序，分页，查询的开发顺序？

## 115、什么是高阶组件？(React)

高阶组件（Higher-Order Component，HOC）是一种在React中用于复用组件逻辑的高级技巧。它本质上来说是一个函数，该函数接受一个组件作为输入并返回一个新的组件。 高阶组件可以用来增强组件的功能，例如：添加数据获取、状态管理、路由处理、权限控制等功能。它们可以让代码更加简洁、可读性更强，并且可以让组件的功能更加单一，易于维护和测试。

一个高阶组件通常会做以下事情：

1. 接受一个组件作为输入参数；

2. 创建一个新的组件；

3. 通过props向新组件传递一些额外的属性或者重写一些属性；

4. 返回这个新组件。 以下是一个简单的高阶组件示例：

   ```js
   function withLoading(Component) {
     return function(props) {
       const { isLoading, ...rest } = props;
       if (isLoading) {
         return <div>Loading...</div>;
       } else {
         return <Component {...rest} />;
       }
     };
   }
   // 使用方法
   const EnhancedComponent = withLoading(SomeComponent);
   ```

   在这个示例中，`withLoading`是一个高阶组件，它接受一个组件`SomeComponent`作为输入，并返回一个新的组件`EnhancedComponent`。在新组件中，根据传入的props来判断是否需要显示Loading图标，如果需要，则显示Loading，否则渲染原始组件。

## 116、什么是受控组件和非受控组件？(React)

受控组件是指由React控制其值和状态的组件。这通常通过监听事件并更新组件的state来实现。例如，一个受控的文本输入框会在每次用户输入时更新其值，并将其值存储在组件的state中。这样，React就可以控制组件的状态，以确保它始终保持在React所期望的状态。 非受控组件是指其值和状态不受React控制的组件。这通常是通过使用原生DOM元素的引用来实现的，而不是通过React组件的state。例如，一个非受控的文本输入框可以直接从DOM元素中获取其值，并且在每次用户输入时不需要更新组件的state，因为它的值已经被存储在DOM元素中。 总的来说，受控组件是更加可控和可预测的，因为它们的状态由React管理。但是，非受控组件可能会更加灵活和快速，因为它们不需要与React的状态同步。

## 117、React如何做性能优化？

React的性能优化主要包括以下几个方面：

1. Virtual DOM：React使用虚拟DOM来减少直接操作DOM带来的性能损失。React将组件的状态存储在虚拟DOM中，并在每次状态变化时重新计算虚拟DOM的差异，然后只更新差异部分的真实DOM。
2. 合理使用shouldComponentUpdate：shouldComponentUpdate是React生命周期方法之一，用于决定组件是否需要重新渲染。在shouldComponentUpdate中，可以通过比较前后状态的差异，决定是否需要重新渲染。这个方法可以帮助我们避免不必要的重复渲染，提高性能。
3. 使用PureComponent：PureComponent是React中的一个优化组件，它内部实现了shouldComponentUpdate方法的浅比较，从而避免了不必要的重复渲染。但是，使用PureComponent需要注意，因为它只进行浅比较，如果组件内部有复杂的数据结构，可能会导致错误的结果。
4. 避免渲染大量数据：当需要渲染大量数据时，可以使用分页或者懒加载等方式，避免一次性渲染大量数据。另外，可以使用React-virtualized等第三方库来优化大量数据的渲染。
5. 使用Keys：在渲染数组时，为每个元素添加唯一的Key属性，可以帮助React更高效地更新组件。
6. 使用Immutable.js等库：Immutable.js是一个不可变数据结构的库，它可以帮助我们减少不必要的对象拷贝，从而提高性能。 综上所述，React的性能优化主要包括使用虚拟DOM、合理使用shouldComponentUpdate、使用PureComponent、避免渲染大量数据、使用Keys和使用Immutable.js等库。我们可以根据具体情况选择合适的优化方式来提高应用的性能。

## 118、什么是作用域提升？(变量提升)

​		作用域提升是指在代码执行前将模块中的所有导入的变量声明提升到模块的顶部，从而减少模块内部函数作用域的数量，提高代码的执行效率。 在ES6之前，JavaScript的变量声明只有两种：全局变量和函数作用域变量，因此在函数内部声明变量时，如果不使用var、let或const关键字，这个变量就会成为全局变量。这就会导致变量的命名冲突，同时也会增加代码的复杂度和难度。 而在ES6中，引入了let和const关键字，使得变量声明可以在块级作用域中进行，从而使得变量声明更加规范化和精确化。同时，ES6还引入了作用域提升的概念，将模块中所有导入的变量声明提升到模块的顶部，从而避免了变量命名冲突和不必要的作用域嵌套，同时也提高了代码的执行效率。 作用域提升可以减少函数作用域的数量，使得代码更加简洁和易读，同时也可以提高代码的执行效率，从而更好地满足现代Web应用对高性能、高可维护性的要求。

## 119、什么是作用域和作用域链？

作用域是指在程序中定义变量的区域。JavaScript中有全局作用域和局部作用域。全局作用域是指在函数外部定义的变量，它的作用域是整个程序。局部作用域是指在函数内部定义的变量，它的作用域是函数内部。 作用域链是指在JavaScript中，每个函数都有自己的作用域链，用于解析变量的引用。当一个函数被执行时，它会创建一个新的作用域链，该作用域链包含了当前函数的变量对象，以及它的父级函数的变量对象。当访问一个变量时，JavaScript会先从当前函数的变量对象中查找，如果没有找到，就会向父级函数的变量对象中查找，直到找到全局作用域为止。这个过程就是作用域链的查找过程。 作用域链的创建是在函数声明时确定的，而不是在函数执行时确定的。每个函数都有一个[[Scope]]属性，它指向了该函数的作用域链。当函数被调用时，会创建一个新的执行上下文，并将该函数的[[Scope]]属性赋值给执行上下文的作用域链，从而形成了执行上下文的作用域。 作用域和作用域链是JavaScript中非常重要的概念，理解它们可以帮助我们更好地理解JavaScript的变量声明和作用域规则，并能够更好地编写高质量的JavaScript代码。

## 120、vue父子通信的方式有哪些？

Vue父子组件通信的方式有以下几种：

1. Props和$emit：父组件通过props向子组件传递数据，子组件通过$emit触发自定义事件将数据传递给父组件。
2. $parent和$children：父组件可以通过$children访问子组件实例，子组件可以通过$parent访问父组件实例。但是这种方式不够灵活，只适用于父子组件之间比较紧密的关系。
3. $refs：父组件通过$refs访问子组件实例，从而可以调用子组件的方法和访问子组件的数据。
4. Event Bus：通过创建一个Vue实例作为中央事件总线，父组件和子组件都可以通过该实例触发或监听事件，从而实现通信。
5. Vuex：Vuex是Vue的状态管理工具，它可以在全局范围内管理应用的状态。父组件和子组件都可以通过Vuex来共享数据和状态，从而实现通信。 在实际开发中，根据不同的场景和需求，我们可以选择不同的通信方式来实现父子组件之间的通信。

## 121、html5的新特性有哪些？

一、Canvas元素

Canvas元素用于在网页上绘制图形，有多重绘制路径、矩形、圆形、字符以及添加图像的方法。Canvas通过js绘制2d图形，并逐像素进行渲染，且假若在图片完成后进行修改，整个场景就会重新绘制

二、表单元素

<datalist>：元素规定输入域的选项列表，使用<input>元素的list元素与<datalist>元素的id绑定；

<keygen>：提供一种检验用户的可靠方法，标签规定用于表单的密钥对生成器字段；

<output>：用于不用类型的输出，比如计算或脚本输出。

三、表单属性

placehoder属性：简短的提示在用户输入值前会显示在输入域上，既默认框提示；

required属性：是一个boolean属性，要求填写的输入域不为空；

pattern属性：描述了一个正则表达式用于验证<input>元素的值；

max/min属性：最大最小值；

step属性：为输入域规定合法的数字间隔；

height/width属性：用于image类型的<input>标签的图像高度和宽度；

autofocus属性：是一个boolean属性，在页面加载时自动获得焦点；

multiple属性：是一个boolean属性，规定<input>元素中选择多个值。

三、语义化标签

语义化标签既是使标签有自己的含义，语义化标签的优势：（1）使界面的代码结构清晰，方便代码的阅读和团队的合作开发；（2）方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页；（3）有利于搜索引擎优化（SEO）。

四、媒体元素

播放音频文件的元素<audio>————<audio controls>

（1）control属性提供播放暂停和音量控件；

（2）<audio>和<audio/>之间插入浏览器不支持的<audio>元素的提示文本；

（3）允许使用多个<source>元素用来链接不同的音频文件，浏览器使用第一个支持的音频文件；

（4）支持三种音频格式文件：mp3、wax、ogg。

播放视屏文件的元素<video>

（1）control属性提供播放暂停和音量控件，也可以使用dom操作：play()和pause()；

（2）video元素提供了width和height控制视频的尺寸。如果设置了就会在页面加载时保留，没设置就不保留，页面根据原始视频改变。

五、地理定位

HTML5使用getCurrentPosition()方法来获取用户的位置，可以基于此实现计算位置距离。



## 122、c3新增特性？

CSS3是CSS标准的第三个版本，它引入了许多新特性和功能，包括但不限于以下几个方面：

1. 盒子模型：CSS3引入了新的盒子模型（box-sizing），可以更好地控制元素的尺寸和边框。
2. 边框和背景：CSS3新增了一些新的边框样式（border-image）、背景样式（background-clip、background-origin、background-size）和渐变效果（linear-gradient、radial-gradient），可以创建更加丰富和复杂的界面效果。
3. 字体和文本：CSS3引入了新的字体属性（@font-face、font-stretch、font-feature-settings）和文本属性（text-overflow、text-shadow、text-wrap、text-decoration-color等），可以更好地控制网页的字体和文本效果。
4. 2D和3D转换：CSS3支持2D和3D转换（transform），可以通过旋转、平移、缩放等方式实现复杂的界面效果和动画效果。
5. 动画和过渡：CSS3支持动画（animation）和过渡（transition），可以实现更加复杂和流畅的交互式效果和动画效果。
6. 弹性布局和栅格布局：CSS3支持弹性布局（flexbox）和栅格布局（grid），可以更好地实现响应式布局和自适应布局。
7. 多列布局：CSS3支持多列布局（multi-columns），可以将文本分成多列显示，提高页面的可读性和可访问性。
8. 媒体查询：CSS3支持媒体查询（media query），可以根据不同的设备和屏幕尺寸自动调整网页的布局和样式，提高网页的可访问性和用户体验。 总之，CSS3为网页设计和开发带来了许多新特性和功能，可以让开发者更加方便地创建高质量、高性能的网页和应用程序。

## 123、Ajax请求数据的流程？

Ajax是一种异步请求数据的技术，它能够在不刷新整个页面的情况下向服务器请求数据，从而提高网页的响应速度和用户体验。其主要流程包括以下几个步骤：

1. 创建XMLHttpRequest对象：使用JavaScript创建XMLHttpRequest对象，该对象可以向服务器发送请求和接收响应数据。
2. 绑定回调函数：在创建XMLHttpRequest对象后，需要指定回调函数，该函数会在服务器响应数据后自动调用。回调函数通常用于处理服务器响应的数据，可以将数据显示在网页上或进行其他处理操作。
3. 发送请求：使用XMLHttpRequest对象向服务器发送请求，可以通过open()和send()方法发送GET或POST请求，并传递要发送的数据。
4. 服务器响应：服务器接收到请求后，会返回相应的数据，XMLHttpRequest对象会自动将响应数据传递给回调函数进行处理。
5. 处理响应数据：回调函数会处理服务器响应的数据，可以将数据显示在网页上或进行其他处理操作。
6. 更新网页内容：最后，可以将处理后的数据更新到网页上，以实现无刷新更新网页内容的效果。 总之，Ajax通过异步请求数据的方式实现了网页内容的无刷新更新，从而提高了用户体验和网页性能。

## 124、怎么实现单点登录？

单点登录SSO(Single Sign On)就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任，下面是主要的单点登录方式。

**以Cookie作为凭证媒介**

最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。 用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。

**通过JSONP实现**

对于跨域问题，可以使用JSONP实现。 用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。

**通过页面重定向的方式**

最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。 父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。

**使用独立登录系统**

一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。 用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。

## 125、react有几个生命周期？有哪些阶段？

React组件生命周期有三个阶段：挂载阶段、更新阶段和卸载阶段，共计十个生命周期函数。具体如下： **挂载阶段：**

1. constructor()：构造函数，在组件实例化时调用，用于初始化组件状态和绑定事件处理函数等。
2. static getDerivedStateFromProps()：静态函数，在组件渲染之前调用，用于根据新的 props 计算并返回一个更新状态的对象。
3. render()：必须实现的函数，负责渲染组件的 UI，返回一个 React 元素或 null。
4. componentDidMount()：组件渲染完成后调用，通常用于发起网络请求或订阅事件等操作。 **更新阶段：**
5. shouldComponentUpdate()：在组件更新之前调用，用于判断是否需要重新渲染组件，返回一个布尔值，决定是否触发 render() 函数。
6. static getDerivedStateFromProps()：静态函数，在组件更新之前调用，用于根据新的 props 计算并返回一个更新状态的对象。
7. render()：必须实现的函数，负责渲染组件的 UI，返回一个 React 元素或 null。
8. getSnapshotBeforeUpdate()：在组件更新之前调用，用于获取 DOM 元素的快照，返回一个值，作为 componentDidUpdate() 函数的第三个参数。
9. componentDidUpdate()：在组件更新之后调用，通常用于更新 DOM 元素或执行其他副作用操作。 **卸载阶段：**
10. componentWillUnmount()：在组件卸载之前调用，通常用于清除定时器、取消网络请求等操作。 总之，React 的生命周期函数可以帮助我们控制组件的渲染和更新流程，以及实现一些特定的业务逻辑。在实际开发中，我们需要根据具体的需求选择合适的生命周期函数来处理组件的状态和行为。

## 126、react中组件通信的方式？

React 中组件通信的方式主要有以下几种：

1. 父组件向子组件通信： 父组件可以通过 props 属性向子组件传递数据和函数，子组件可以通过 props 属性接收并使用这些数据和函数。
2. 子组件向父组件通信： 子组件可以通过 props 属性接收父组件传递的回调函数，调用这些函数来向父组件传递数据或事件。
3. 兄弟组件通信： 如果兄弟组件之间需要进行通信，则需要通过共同的父组件或使用全局状态管理库（如 Redux、MobX 等）来实现。
4. 跨级组件通信： 如果组件之间存在多层嵌套关系，可以通过 props 属性层层传递或使用 Context API 来实现跨级组件通信。
5. 发布订阅模式： 可以使用 EventEmitter 或自定义事件触发器等实现发布订阅模式来实现组件间通信。 总之，React 中组件通信的方式有很多种，可以根据具体的业务场景和需求选择合适的方式，以实现组件之间的数据传递和交互。

## 127、useCallback和useMemo的区别？

React 中的 useCallback 和 useMemo 都是用来优化函数组件性能的 Hook，它们的区别如下：

1. 功能不同： `useCallback` 是用来缓存函数的引用，以便在依赖项没有改变的情况下，避免函数的重复创建。它接收两个参数，第一个参数是需要缓存的函数，第二个参数是依赖项数组，当依赖项数组发生变化时，返回一个新的函数引用。 `useMemo` 是用来缓存值的引用，以便在依赖项没有改变的情况下，避免重复计算相同的值。它接收两个参数，第一个参数是一个函数，在该函数中可以进行复杂的计算操作，第二个参数是依赖项数组，当依赖项数组发生变化时，重新计算并返回一个新的值引用。
2. 返回值不同： `useCallback` 返回一个缓存后的函数引用，可直接作为回调函数传递给子组件使用。 `useMemo` 返回一个缓存后的值引用，可以在 JSX 中直接使用。
3. 使用场景不同： `useCallback` 适用于需要使用缓存的回调函数，避免重复创建函数引用的场景，例如将一个回调函数传递给子组件时； `useMemo` 适用于需要缓存复杂计算结果的场景，可以减少重复计算，例如计算并缓存一个组件的 props 值。 总之，useCallback 和 useMemo 在性能优化方面都有很大的作用，可以根据具体的业务需求和场景选择合适的 Hook 进行使用。

## 128、React中fiber的理解？

Fiber是React v16引入的一种新的协调机制，它的目的是为了解决之前的调和过程（reconciliation）无法中断、难以维护状态以及无法控制优先级等问题。Fiber实际上是一个虚拟的堆栈帧，通过Fiber节点的形式记录了组件树的结构及其状态信息，同时也记录了遍历过程的中间状态，可以随时中断、恢复并且可以优先级调度，从而更好地控制整个组件树的渲染过程。 在React中，每一个组件都对应一个Fiber节点，Fiber节点中包含了组件的类型、props、state、以及一些与调和过程相关的信息，如更新队列、副作用列表等。Fiber节点通过形成单向链表的形式，表达了整个组件树的结构。当更新发生时，React遍历Fiber节点，根据其状态判断是否需要更新，并将更新的操作加入到该节点的更新队列中。在遍历过程中，React可以根据Fiber节点的优先级进行暂停、恢复、重复、跳过等操作，从而更好地控制整个组件树的渲染过程。 总的来说，Fiber算法是React为了提升渲染性能而引入的一种新的调和机制，它将组件树的遍历过程分解成多个阶段，并通过记录中间状态，使得遍历过程可以被中断、恢复、调整优先级等，从而更好地控制整个组件树的渲染过程。

## 129、mobx的原理？

MobX 是一个状态管理库，它基于响应式编程的思想，使得状态和UI之间的同步变得非常简单。MobX 的原理可以概括为三个核心概念：observable、action 和 reaction。

1. Observable Observable 用于将某个状态转化为可观察的状态，使得这个状态可以被观察到。当这个状态发生变化时，所有依赖这个状态的函数或组件都会自动更新。
2. Action Action 是一种可以修改状态的操作，它是对状态的改变进行封装的方式。在 MobX 中，只有使用 action 才能修改被 observable 包裹的状态。
3. Reaction Reaction 是对状态变化的响应。当某个被观察的状态发生变化时，所有依赖这个状态的函数或组件都会被重新计算。这个过程被称为 Reaction，它是 MobX 实现自动更新的关键。 在 MobX 的应用中，我们通常会将 observable 的状态放在 store 中，然后通过 action 来修改 store 中的状态。当 store 中的状态发生变化时，所有依赖这个状态的组件都会自动更新。 总的来说，MobX 的原理可以概括为：通过将状态转化为可观察的状态，封装状态变化的操作，并对状态变化进行响应，实现了状态和 UI 之间的同步更新。这种方式相对于传统的状态管理方式，可以使得代码变得更加简单、易于维护。

## 130、React和vue的区别是什么？

React和Vue都是目前最流行的前端框架之一，它们虽然都用于构建用户界面，但是在实现方式、思想和特点上有一些不同。

1. 实现方式 React使用JSX，将组件的结构、样式和行为全部封装在一个JSX文件中，提供了更加灵活的组件化开发方式。而Vue使用的是单文件组件，将组件的结构、样式和行为都放在一个.vue文件中，使得开发过程更加简洁。
2. 响应式原理 Vue使用双向数据绑定，通过数据劫持实现数据与视图的自动同步，可以让开发者更加方便地管理组件的状态。而React使用单向数据流，通过props和state来实现组件的状态管理，可以更好地控制数据的流动。
3. 组件通信 Vue提供了多种组件通信方式，包括props、事件、$emit和$on等，可以使得组件之间的通信更加方便。React则采用了逐层传递props的方式进行组件间通信，同时也提供了Context和Redux等状态管理工具。
4. 生态系统 React生态系统非常庞大，拥有丰富的第三方库和组件，同时也有大量的文档和社区支持。Vue生态系统也在不断壮大，有着完善的官方文档和社区支持。 总的来说，React和Vue都是优秀的前端框架，它们各有特点，选择哪个框架取决于具体的项目需求和个人的偏好。如果需要更灵活的组件化开发方式和更好的生态系统支持，可以选择React；如果需要更简洁的开发方式和更方便的组件通信方式，可以选择Vue。

## 131、谈谈对React中diff算法和虚拟Dom的理解？

React框架中的Virtual DOM和Diff算法是React性能优秀的重要原因之一。

1. 理解Virtual DOM Virtual DOM是指将真实的DOM抽象成一个轻量级的对象，在React中，每个组件都有自己对应的Virtual DOM。当组件的状态发生改变时，React会通过对比新旧Virtual DOM，找出需要更新的部分，最终只对这些部分进行更新操作，从而避免了对整个DOM树的重新渲染。

2. 理解Diff算法 Diff算法是指在进行Virtual DOM比较时，React采用的一种高效的算法，它可以在O(n)的时间复杂度内找出需要更新的部分。 React的Diff算法主要分为两个步骤：同层比较和跨层比较。 同层比较是指在进行Virtual DOM比较时，React会首先比较同级别的节点，这样可以尽可能地减少DOM操作的次数。 跨层比较是指在同层比较完成后，React会比较不同层次之间的节点，这可能会导致DOM操作的次数增加，但是由于同层比较的优化，所以跨层比较的次数通常很少。

3. Diff算法的执行过程 Diff算法执行过程如下： 

   （1）首先比较两个树的根节点，如果节点类型不同，则直接替换，不再进行后续比较。 

   （2）如果节点类型相同，则比较节点属性，如果属性不同，则直接替换，不再进行后续比较。 

   （3）如果节点类型和属性都相同，则比较子节点。 

   （4）如果子节点都存在，则按照同层比较的方式依次进行比较。 

   （5）如果新节点的子节点比旧节点的多，则新节点多出的子节点直接插入到DOM中，如果新节点的子节点比旧节点的少，则旧节点多出的子节点直接从DOM中删除。 （6）如果子节点存在，则按照跨层比较的方式依次进行比较。 

   （7）如果新节点的子节点在旧节点中不存在，则直接插入到DOM中。 （8）如果旧节点的子节点在新节点中不存在，则直接从DOM中删除。 通过这种方式，React可以避免对整个DOM树的重新渲染，从而提高了应用程序的性能。 总的来说，React中的Virtual DOM和Diff算法是React性能优秀的重要原因之一，它们可以避免对整个DOM树的重新渲染，从而提高了应用程序的性能。

## 132、React中Context的理解？

Context是React框架中用于在组件之间共享数据的一种机制。Context提供了一种在组件之间共享数据的方式，而不需要将数据通过props层层传递，这可以简化组件之间的数据传递过程。

1. 创建Context对象 在使用Context之前，需要先创建一个Context对象，可以通过React.createContext()方法来创建一个Context对象。例如：

   ```js
   const MyContext = React.createContext(defaultValue);
   ```

   其中，defaultValue是Context的默认值，当组件没有找到对应的Provider时，会使用默认值作为Context的值。 2. 使用Provider组件 在使用Context之前，需要使用Provider组件来提供Context的值。Provider组件可以通过value属性来设置Context的值。例如：

   ```js
   <MyContext.Provider value={/* some value */}>
     {/* child components */}
   </MyContext.Provider>
   ```

   在Provider组件内部可以使用任意的React组件，包括其他的Provider组件和Consumer组件，但是要保证每个Provider组件都应该有一个对应的Consumer组件。 3. 使用Consumer组件 在使用Context的组件中，可以通过Consumer组件来订阅Context的值。Consumer组件可以通过函数作为子元素的方式来订阅Context的值，并将Context的值作为参数传递给函数。例如：

   ```ts
   <MyContext.Consumer>
     {value => /* render something based on the context value */}
   </MyContext.Consumer>
   ```

   在上述例子中，value是从Provider组件中传递过来的Context的值，可以根据value的值来渲染组件。 总的来说，Context是React框架中用于在组件之间共享数据的一种机制，它可以简化组件之间的数据传递过程，提高组件的复用性和可维护性。但是需要注意，在使用Context时要避免过度使用，以免造成代码的混乱和不必要的性能问题。

## 133、该怎么渲染大量长度数组？(10w条）

在React中渲染大量长度数组时，如果使用传统的方式直接将数组元素通过map方法渲染成组件，可能会导致性能问题，因为这样会生成大量的DOM节点，导致页面渲染缓慢。为了避免这种情况，可以采用以下几种方式来优化渲染性能：

1. 分段加载：可以将大数组分成多个小数组，然后分段进行加载，这样可以避免一次性加载大量的数据。例如，可以使用React-virtualized库，它提供了一种虚拟滚动的方式，只渲染屏幕内可见的部分数据，其他数据则在滚动时动态加载。
2. 使用shouldComponentUpdate或React.memo进行浅比较：在组件渲染时，可以使用shouldComponentUpdate或React.memo进行浅比较，判断是否需要更新组件。这样可以避免不必要的DOM操作，提高渲染性能。
3. 使用window.requestAnimationFrame：可以使用window.requestAnimationFrame方法来延迟渲染，这样可以将多次渲染操作合并成一次，减少DOM操作的次数，提高性能。
4. 使用Web Workers：可以使用Web Workers将数组渲染操作放在一个独立的线程中，避免阻塞主线程，提高渲染性能。
5. 使用React.lazy和Suspense：可以使用React.lazy和Suspense来实现组件的按需加载，只有当组件需要渲染时才会动态加载，避免一次性加载大量组件导致的性能问题。 总的来说，渲染大量长度数组时，需要采用合适的优化策略来提高渲染性能，避免页面渲染缓慢和卡顿的问题。

## 134、什么是虚拟列表？怎么实现？

虚拟列表（Virtual List）是一种优化长列表渲染性能的技术，它只渲染可视区域内的列表项，而不是将整个列表都渲染出来。虚拟列表的实现可以分为两个部分：计算可视区域和渲染可视区域内的列表项。

1. 计算可视区域 计算可视区域的过程包括以下几个步骤：

- 获取列表容器的高度和宽度。
- 获取每个列表项的高度。
- 计算可视区域内的列表项数量。
- 计算列表总高度。

1. 渲染可视区域内的列表项 渲染可视区域内的列表项可以通过以下两种方式实现：

- 将可视区域内的列表项通过map方法渲染成组件，并将组件添加到页面上。
- 通过绝对定位和transform属性来实现列表项的滚动效果。 其中，第一种方式比较简单，但是在渲染大量数据时可能会存在性能问题。为了避免这种问题，可以采用window.requestAnimationFrame方法来分批渲染列表项，避免一次性渲染大量数据导致的性能问题。 而第二种方式则是通过绝对定位和transform属性来实现列表项的滚动效果，这种方式可以避免渲染大量数据导致的性能问题，但是需要注意在计算列表项位置时需要考虑滚动条的高度和宽度。 总的来说，虚拟列表是一种优化长列表渲染性能的技术，它可以通过计算可视区域和渲染可视区域内的列表项来提高渲染性能。虚拟列表的实现可以通过map方法渲染组件或通过绝对定位和transform属性来实现列表项的滚动效果。

## 135、Rect项目中遇到的项目难点？怎么解决？

在React项目开发中，可能会遇到各种各样的难点，以下是我在React项目中遇到的一些难点及其解决方法：

1. 性能优化：在渲染大量数据时可能会导致性能问题。可以通过使用虚拟列表、shouldComponentUpdate或React.memo进行浅比较、使用Web Workers等方式来优化渲染性能。
2. 状态管理：在状态管理方面，可能会遇到状态共享、状态更新等问题，可以采用Redux、Mobx等状态管理库来解决。
3. 组件复用：在组件复用方面，可能会遇到组件耦合、组件逻辑重复等问题，可以采用高阶组件、Render Props等方式来实现组件复用。
4. 跨域问题：在调用后端API时可能会遇到跨域问题，可以通过配置代理服务器、使用JSONP等方式来解决。
5. 异步请求：在异步请求方面，可能会遇到多个请求并行执行、请求顺序问题等问题，可以采用Promise、async/await等方式来解决。
6. 路由管理：在路由管理方面，可能会遇到路由配置、路由嵌套等问题，可以采用React Router等路由管理库来解决。 总的来说，在React项目中遇到的难点各不相同，需要根据具体情况采用不同的解决方案。同时，要保持学习和探索的心态，不断优化和改进自己的开发技能。

## 136、项目中有没有使用js加密，怎么使用的？

在实际项目中，可能会需要对一些敏感数据进行加密，以保证数据的安全性。在JavaScript中，常见的加密算法包括MD5、SHA、AES等。以下是一些常用的加密方法：

1. MD5加密：可以使用crypto-js库的MD5方法进行加密。例如：

   ```js
   import CryptoJS from 'crypto-js';
   // 加密字符串
   const encryptedStr = CryptoJS.MD5('hello world').toString();
   console.log(encryptedStr); // 输出5eb63bbbe01eeed093cb22bb8f5acdc3
   ```

   2、SHA加密：可以使用crypto-js库的SHA方法进行加密。例如：

   ```js
   import CryptoJS from 'crypto-js';
   // 加密字符串
   const encryptedStr = CryptoJS.SHA256('hello world').toString();
   console.log(encryptedStr); // 输出2ef7bde608ce5404e97d5f042f95f89f1c232871dfcc1e1a2924e4a5d8f81bb1
   ```

   3、AES加密：可以使用crypto-js库的AES方法进行加密。例如：

   ```
   import CryptoJS from 'crypto-js';
   // 加密字符串
   const encryptedStr = CryptoJS.AES.encrypt('hello world', 'secret key').toString();
   console.log(encryptedStr); // 输出U2FsdGVkX18qxjK6+0+f0Ib2F9s+4KQ2C4J4RZ+OJZk=
   ```

   在使用加密算法时需要注意，加密算法本身并不能完全保证数据的安全性，仍然需要采用其他方式来保证数据的安全性，例如HTTPS协议、防止SQL注入等。

## 137、您知道的设计模式有哪些？

常见的设计模式有以下几种：

1. 工厂模式（Factory Pattern）：用于创建对象，将对象的创建和使用分离，避免了代码耦合。
2. 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供全局访问点。
3. 观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。
4. 策略模式（Strategy Pattern）：定义一系列算法，将每个算法封装起来并使它们可以互换，使得算法的变化不会影响到使用算法的客户端。
5. 适配器模式（Adapter Pattern）：通过包装一个对象来适配不同接口，使得原本由于接口不兼容而不能在一起工作的对象可以在一起工作。
6. 装饰者模式（Decorator Pattern）：动态地将责任附加到对象上，若要扩展功能，装饰者为了达到这个目的，而使用了装饰的方式，而不是修改原有对象。
7. 命令模式（Command Pattern）：将一个请求封装成一个对象，使得可以用不同的请求对客户端进行参数化，同时将请求的对象放入队列中进行管理。
8. 迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
9. 模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
10. 外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用。
11. 组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 总的来说，设计模式是一种经验总结，可以帮助开发人员更好地编写可重用、可扩展、易维护的代码。

## 138、说出10种数组常用方法？

以下是10种数组常用方法：

1. push()：向数组末尾添加一个或多个元素，并返回新的长度。
2. pop()：删除并返回数组的最后一个元素。
3. shift()：删除并返回数组的第一个元素。
4. unshift()：向数组开头添加一个或多个元素，并返回新的长度。
5. splice()：删除并添加数组中的元素。该方法可以实现删除、插入和替换元素的操作。
6. slice()：返回一个新的数组，包含从开始到结束（不包括结束）的元素。该方法不会修改原始数组。
7. concat()：返回一个新的数组，包含原始数组与传入的数组或值连接而成的新数组。
8. join()：将数组中的所有元素转换为一个字符串，并用指定的分隔符将它们连接起来。
9. indexOf()：返回数组中指定元素的第一个出现位置的索引。如果没有找到该元素，则返回-1。
10. forEach()：遍历数组中的每个元素，并对每个元素执行指定的函数。该方法不会修改原始数组。



## 139、小程序的运行原理？

小程序的运行原理主要分为以下几个步骤：

1. 用户打开小程序，微信客户端向微信服务器发起请求，获取小程序的代码包和相关配置信息。
2. 微信客户端根据代码包和配置信息构建虚拟运行环境（下称 WXML 渲染层和 JS 逻辑层），并将渲染层和逻辑层载入内存。
3. 渲染层通过 WXML 和 WXSS 标记语言生成小程序的视图层（下称 Native 渲染层），并将视图层显示在用户的手机屏幕上。
4. 用户进行操作，如点击按钮、输入内容等，微信客户端将用户的操作转发给逻辑层。
5. 逻辑层根据用户的操作，在内存中对数据进行增删改查等操作，然后通过通信桥将数据更新到渲染层。
6. 渲染层根据最新的数据，生成新的 Native 渲染层，并将其显示在用户的手机屏幕上。
7. 如此往复，用户与小程序进行交互，直至用户关闭小程序。 总的来说，小程序采用了类似于浏览器的运行机制，将前端代码和逻辑层放在云端，通过虚拟运行环境实现小程序的运行。同时，小程序还针对移动端设备的特点，对运行机制进行了优化，使得小程序可以具有更快的启动速度和更高的性能表现。



## 140、小程序的有点和缺点？

小程序的优点：

1. 快速启动：因为小程序的代码和资源都在微信客户端缓存中，所以启动速度快，用户可以快速进入应用。
2. 无需下载安装：小程序无需下载和安装，用户可以直接在微信中使用，减少了应用安装的烦恼和存储空间的占用。
3. 低成本：相比于原生应用，开发小程序的成本更低，开发周期更短，且不需要为不同的操作系统和设备进行适配。
4. 高效运营：小程序可以基于微信的社交属性，支持分享、转发、评论等功能，方便用户进行社交互动，同时也方便开发者进行运营和推广。
5. 安全可靠：小程序的代码和数据都存储在微信服务器中，具有较高的安全性和可靠性。 小程序的缺点：
6. 功能受限：由于小程序的代码和资源都在微信客户端中，因此受到微信客户端的限制，功能相对于原生应用受到一定的限制。
7. 兼容性问题：小程序在不同的微信客户端版本和操作系统版本中，可能会存在兼容性问题，需要开发者进行适配。
8. 用户留存率低：由于小程序的易于进入和退出，用户的留存率相对较低，需要开发者进行更多的运营和推广。
9. 网络环境依赖性：小程序需要依赖网络环境进行数据传输和资源加载，如果网络环境不好，可能会影响用户的使用体验。
10. 开发门槛较高：虽然小程序相对于原生应用的开发周期和成本较低，但是对于非专业开发者来说，学习和掌握小程序开发的技能门槛还是相对较高的。

## 141、小程序里面常用的API有哪些？

小程序里面常用的API有以下几种：

1. 界面API：如wx.navigateTo、wx.switchTab、wx.showModal等，用于操作页面的跳转、切换、显示弹窗等功能。
2. 网络API：如wx.request、wx.uploadFile、wx.downloadFile等，用于进行网络请求和文件上传下载等操作。
3. 媒体API：如wx.chooseImage、wx.previewImage、wx.createVideoContext等，用于处理图片、音频、视频等媒体文件。
4. 数据API：如wx.getStorageSync、wx.setStorageSync、wx.getStorageInfoSync等，用于数据的存储和获取。
5. 地图API：如wx.getLocation、wx.openLocation、wx.createMapContext等，用于地图的显示和定位等功能。
6. 生物识别API：如wx.checkIsSupportSoterAuthentication、wx.startSoterAuthentication等，用于进行生物识别验证，如指纹、面部识别等。
7. 系统API：如wx.getSystemInfo、wx.setClipboardData、wx.getNetworkType等，用于获取系统信息、设置剪贴板数据、获取网络状态等操作。
8. 开放接口API：如wx.login、wx.getUserInfo、wx.requestPayment等，用于获取用户信息、进行支付等操作。
9. 第三方服务API：如wx.createWorker、wx.getExtConfigSync、wx.getExtConfig等，用于调用第三方服务提供的接口和服务。 总的来说，小程序提供了丰富的API接口，满足了开发者在开发过程中的各种需求，同时也为用户提供了更加丰富和便捷的应用体验。

## 145、Es6新增新特性?

ES6是 ECMAScript 的第六个版本，也称为ES2015。它引入了很多新特性，这里列举一些比较常用的：

1. 箭头函数：使用箭头（=>）定义函数，简化了函数的定义语法，同时也可以避免this指向的问题。
2. let和const：let和const是块级作用域变量，取代了原来的var关键字，使得代码更加安全和易于维护。
3. 模板字符串：使用反引号（`）定义字符串，可以内嵌变量和表达式，使得字符串的拼接更加方便。
4. 解构赋值：可以方便地从数组或对象中提取值，使得变量的赋值更加简洁。
5. class：引入了类的概念，使得面向对象编程更加方便和直观。
6. Promise：是一种异步编程的解决方案，使得异步操作更加可读和易于维护。
7. 箭头函数：使用箭头（=>）定义函数，简化了函数的定义语法，同时也可以避免this指向的问题。
8. 模块化：引入了import和export关键字，使得模块化编程更加方便和易于维护。
9. 扩展运算符：使用三个点（...）可以将数组或对象展开为多个参数，也可以将多个参数合并为一个数组或对象。
10. 默认参数：可以为函数参数设置默认值，避免了参数缺失的问题。 总之，ES6引入了许多新特性，使得JavaScript语言更加现代化和易于使用，同时也提升了开发效率和代码质量。

## 146、前端性能优化的方法有哪些？

前端性能优化的方法有以下几种：

1. 优化HTTP请求：减少HTTP请求次数、使用CDN、压缩文件、使用浏览器缓存等。
2. 优化图片：使用合适的格式、压缩图片、使用CSS Sprites等。
3. 优化JavaScript：减少JavaScript文件大小、使用异步加载、避免重复计算、使用事件委托等。
4. 优化CSS：使用合适的选择器、避免重复样式、使用CSS预处理器等。
5. 优化DOM操作：减少DOM操作次数、缓存DOM元素、使用合适的选择器等。
6. 优化页面布局：使用合适的布局方式、避免重排等。
7. 优化字体：使用系统默认字体、使用合适的字体大小、避免使用Web字体等。
8. 优化移动端页面：使用响应式布局、使用移动端优化的图片、避免使用动画等。
9. 使用工具：使用性能分析工具、使用代码压缩工具、使用代码检查工具等。 总之，前端性能优化需要从各个方面入手，包括HTTP请求、图片、JavaScript、CSS、DOM操作、页面布局、字体、移动端页面等。同时，使用合适的工具也可以帮助我们更好地优化代码，提升网页性能。

## 147、前端兼容的bug有哪些？

前端兼容性问题是前端开发中比较常见的问题，以下是一些常见的前端兼容性问题及解决方法：

1. 页面布局问题：不同浏览器对CSS的解析方式不同，可能导致页面布局错乱。解决方法可以使用CSS reset样式表、使用浏览器前缀等。
2. JavaScript兼容性问题：不同浏览器对JavaScript的支持也有所不同，可能导致某些功能不能正常使用。解决方法可以使用polyfill库、检测浏览器类型等。
3. CSS3样式兼容性问题：一些比较新的CSS3样式在一些旧版本的浏览器中不被支持。解决方法可以使用CSS预处理器、使用JavaScript实现等。
4. 响应式布局兼容性问题：在不同设备上，页面的布局和排版可能会发生变化，导致页面显示异常。解决方法可以使用媒体查询、使用rem单位等。
5. 图片兼容性问题：在一些浏览器或系统中，可能无法支持某些图片格式。解决方法可以使用图片格式转换工具、使用WebP格式等。
6. 表单兼容性问题：不同浏览器对表单的支持也有所不同，可能导致表单元素的样式和行为不一致。解决方法可以使用表单重置样式表、检测浏览器类型等。 总的来说，前端兼容性问题是前端开发中不可避免的问题，需要我们在开发中注意兼容性问题，使用合适的解决方法来保证页面的兼容性。

## 148、promise有几种状态，分别是什么？

Promise有三种状态，分别是：

1. Pending（进行中）：Promise对象刚被创建时的初始状态，表示异步操作正在进行中，尚未完成。
2. Fulfilled（已成功）：异步操作成功完成时的状态，表示Promise对象的异步操作已经成功完成，此时Promise对象的then方法会被调用。
3. Rejected（已失败）：异步操作失败时的状态，表示Promise对象的异步操作已经失败，此时Promise对象的catch方法会被调用。 一旦Promise对象的状态从Pending转变为Fulfilled或Rejected，就不会再发生变化，称为“resolved”（已定型）。当然，一旦状态变成resolved，Promise对象的then方法就会立即执行，因此可以把异步操作的结果放在then方法中进行处理。

## 150、文件上传的流程，有没有遇到什么棘手问题？

## 151、文件过大怎么办?

## 152、前端怎么导出excel数据和pdf？

前端导出excel数据和pdf可以使用以下方法：

1. 导出Excel数据：可以使用第三方库，如ExcelJS、SheetJS等，通过JavaScript生成Excel文件，然后提供下载链接供用户下载。

   ```js
   // 使用ExcelJS生成Excel文件
   const workbook = new ExcelJS.Workbook();
   const worksheet = workbook.addWorksheet('My Sheet');
   worksheet.columns = [
     { header: 'Id', key: 'id', width: 10 },
     { header: 'Name', key: 'name', width: 32 },
     { header: 'D.O.B.', key: 'dob', width: 15, }
   ];
   worksheet.addRow({ id: 1, name: 'John Doe', dob: new Date(1970,1,1) });
   workbook.xlsx.writeBuffer().then(buffer => {
     const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
     const url = URL.createObjectURL(blob);
     const link = document.createElement('a');
     link.href = url;
     link.download = 'example.xlsx';
     document.body.appendChild(link);
     link.click();
     document.body.removeChild(link);
   });
   ```

   2、导出PDF：可以使用第三方库，如jsPDF、pdfmake等，通过JavaScript生成PDF文件，然后提供下载链接供用户下载。

   ```js
   // 使用jsPDF生成PDF文件
   const doc = new jsPDF();
   doc.text('Hello, world!', 10, 10);
   doc.save('example.pdf');
   ```

   需要注意的是，前端导出文件只能导出客户端上已经存在的数据，不能直接操作服务器上的文件。因此，在导出文件之前，需要先从服务器获取需要导出的数据，然后进行处理和转换，最后才能导出文件。

## 153、webpack常用插件?

常用的Webpack插件

- HtmlWebpackPlugin：将打包后的 JS 文件自动插入到 HTML 模板中，并生成一个新的 HTML 文件。
- MiniCssExtractPlugin：将CSS提取到独立的文件中，以便于浏览器缓存。
- DefinePlugin：允许在代码中定义全局常量。
- HotModuleReplacementPlugin：支持热更新，在开发过程中无需手动刷新页面即可实时看到修改效果。
- UglifyJsPlugin：压缩JavaScript代码，以减少文件大小和加载时间。
- CleanWebpackPlugin：在每次打包之前清除之前打包生成的文件。
- CopyWebpackPlugin：将文件从源目录复制到目标目录，例如将静态文件复制到打包后的目录中。
- BundleAnalyzerPlugin：分析打包后的文件大小和依赖关系。

## 154、webpack怎么进行性能优化？

Webpack可以通过以下方式进行性能优化：

1. 减少打包体积：可以通过代码压缩、tree shaking、按需加载等方式减少打包后的文件体积。
2. 缩短构建时间：可以通过缓存、多线程打包等方式缩短构建时间。
3. 优化loader配置：可以通过loader选项配置、缓存等方式优化loader性能。
4. 优化resolve配置：可以通过减少resolve的查找路径、使用alias等方式优化resolve性能。
5. 使用externals：将一些依赖库通过cdn引入，减少打包后的文件体积。
6. 使用webpack-bundle-analyzer分析打包后的文件，查看每个模块的体积，避免打包过程中出现不必要的依赖。
7. 拆分打包：将代码按照不同的功能拆分成多个文件，可以减少单个文件的体积，同时也可以利用浏览器并行下载多个文件，提高网页的加载速度。
8. 压缩图片：使用imagemin等插件对图片进行压缩，减少图片的大小，提高网页的加载速度。
9. 使用CDN：将一些公共资源，如jQuery、React、Vue等通过CDN引入，提高网页的加载速度。
10. 使用缓存：使用webpack-manifest-plugin等插件生成manifest.json文件，将文件的hash值与文件名进行映射，可以避免因为文件内容没有变化而导致的浏览器缓存失效。 以上是Webpack进行性能优化的一些方式，可以根据具体项目需求进行选择和配置，提高项目的性能。

## 155、webpack打包流程及其原理？

Webpack的打包流程大致如下：

1. 解析配置文件：Webpack首先读取配置文件，解析其中的配置项，包括入口文件、输出目录、loader、plugin等。
2. 解析依赖：在解析入口文件时，Webpack会根据配置文件中的entry字段找到入口文件，并解析入口文件依赖的其他文件，形成依赖关系图。
3. 加载、转换模块：Webpack根据配置文件中的loader配置，对不同类型的文件进行加载和转换。比如，对于CSS文件，Webpack会加载css-loader和style-loader，将CSS文件转换为JS文件，并将转换后的JS文件注入到HTML文件中。
4. 打包输出：Webpack将所有模块打包成一个或多个文件，根据配置文件中的output字段，将打包后的文件输出到指定目录下。 Webpack的打包原理主要分为以下几个步骤：
5. 将入口文件和依赖文件转换成AST（抽象语法树）：Webpack使用acorn或babel等工具，将JS文件解析成AST格式，方便对JS代码进行分析和处理。
6. 分析依赖：Webpack根据AST分析出入口文件和依赖文件之间的依赖关系，形成依赖关系图。
7. 根据依赖关系图生成Chunk：Webpack将所有依赖关系图中的模块分组，生成一个或多个Chunk。每个Chunk包含多个模块，以及这些模块之间的依赖关系。
8. 将Chunk转换成Bundle：Webpack将每个Chunk转换成一个或多个Bundle。每个Bundle包含一个或多个JS文件，以及这些文件之间的依赖关系。
9. 输出Bundle：Webpack将所有Bundle输出到指定目录下，生成最终的打包文件。 以上是Webpack的打包流程和原理，了解这些原理有助于我们更好地理解Webpack的工作原理，从而更好地进行配置和优化。

## 156、网络通讯socket的基本原理？

Socket是一种网络通信协议，它提供了一种可靠的、基于流的、双向通信的机制，可以在网络上进行数据传输。Socket通信的基本原理如下：

1. 服务器端启动并监听指定的端口号，等待客户端的连接请求。
2. 客户端向服务器发起连接请求，包括服务器的IP地址和端口号。
3. 服务器接收到连接请求后，将创建一个新的Socket对象，与客户端建立连接。
4. 服务器与客户端之间可以进行双向通信，可以发送和接收数据。
5. 通信结束后，服务器和客户端都可以关闭Socket连接，释放资源。 在Socket通信过程中，需要使用TCP/IP协议，包括IP地址、端口号、连接状态等信息。客户端和服务器之间的通信都是基于这些信息进行的。 Socket通信的优点是可以实现可靠的、双向的数据传输，可以在网络上进行实时通信，可以有效地进行数据交换和处理。它在网络编程中有着广泛的应用，如网络游戏、在线聊天、视频直播等领域。

## 157、微信公众号开发和H5开发的区别是什么？

微信公众号开发和H5开发的区别主要在以下几个方面：

1. 使用场景不同：微信公众号开发主要是为企业或个人提供在微信平台上的服务，如公众号菜单、自动回复、消息推送等；H5开发主要是为用户提供在浏览器中访问的Web应用，如移动端网页、活动页面、小游戏等。
2. 接口调用方式不同：微信公众号开发需要与微信服务器进行交互，需要使用微信提供的开发接口进行调用，如获取用户信息、发送模板消息等；H5开发则不需要与微信服务器进行交互，可以直接调用浏览器提供的Web API。
3. 技术实现方式不同：微信公众号开发使用的是基于微信公众平台的开发框架，如使用Node.js进行开发；H5开发则可以使用传统的Web开发技术，如HTML、CSS、JavaScript等。
4. 开发流程不同：微信公众号开发需要进行微信公众号的认证，需要进行开发者资质认证、公众号认证等步骤；H5开发则无需进行认证，只需要进行Web应用的开发即可。 总之，微信公众号开发和H5开发虽然有些相似之处，但在使用场景、接口调用方式、技术实现方式、开发流程等方面都有不同，需要根据实际需求进行选择。

## 159、有没有微前端开发的经验?

微前端开发是一种将Web应用程序拆分为多个小型、松耦合的部分的方法。每个部分都是一个独立的微前端，可以由不同的团队开发、维护和部署，最终组合成完整的Web应用程序。微前端开发的目标是实现前端的模块化和可扩展性，减少项目的复杂度和维护成本。 微前端开发的主要思想是将一个大型的Web应用程序拆分为多个小型的、独立的组件。每个组件都可以由不同的团队进行开发和维护，以达到代码复用和可扩展性的目的。这些组件可以是单页应用、小型应用或小部件。 微前端开发的优点包括：

1. 降低代码复杂度：通过将Web应用程序拆分为小型、独立的组件，可以降低代码复杂度，提高开发效率。
2. 提高可维护性：每个组件都是独立的，可以由不同的团队进行开发和维护，降低了项目维护的成本。
3. 提高可扩展性：通过组合不同的组件，可以实现Web应用程序的快速扩展和升级。
4. 提高代码复用率：不同的组件可以在不同的Web应用程序中重复使用。 微前端开发的缺点包括：
5. 增加了部署和管理的复杂度：由于微前端开发需要将Web应用程序拆分为多个小型、独立的组件，因此需要增加部署和管理的复杂度。
6. 增加了运行时的复杂度：由于微前端开发需要将不同的组件组合成完整的Web应用程序，因此增加了运行时的复杂度。
7. 增加了前端框架的学习成本：由于微前端开发需要使用不同的前端框架，因此需要增加前端框架的学习成本。 总之，微前端开发是一种将Web应用程序拆分为多个小型、独立的组件的方法，可以实现前端的模块化和可扩展性，减少项目的复杂度和维护成本。

## 160、什么是低代码开发？

低代码开发是一种应用开发方法，它使用可视化编程工具和模型驱动的开发方法，以减少手写代码的需求，从而加速应用程序的开发周期。低代码开发平台提供了一个可视化的开发环境，其中包含了各种预制组件和模板，开发者可以通过简单的拖拽和配置来快速搭建应用程序。这种方法还提供了自动生成代码的功能，使得开发人员可以更快地将应用程序推向市场。 低代码开发的优点包括：

1. 加速开发周期：通过使用可视化工具和模型驱动的开发方法，低代码开发可以大大减少手写代码的时间，从而加速应用程序的开发周期。
2. 提高开发效率：低代码开发可以使开发人员更专注于业务逻辑，而不是编写底层代码的细节。
3. 降低技术门槛：低代码开发可以让非专业的开发人员也可以开发应用程序，从而降低了技术门槛。
4. 降低成本：低代码开发可以大大降低应用程序的开发和维护成本，因为开发人员可以更快地构建应用程序，而且在开发过程中也可以更容易地进行调试和测试。 低代码开发的缺点包括：
5. 有一定的学习曲线：低代码开发平台虽然提供了可视化的工具和模板，但是开发人员仍然需要学习如何使用这些工具和模板。
6. 功能限制：低代码开发平台可能限制了一些高级功能的使用，因为这些功能可能需要更底层的代码来实现。
7. 不适用于所有场景：低代码开发平台适用于一些简单的应用程序，但是对于更复杂的应用程序，可能需要更底层的代码来实现。 总之，低代码开发是一种应用开发方法，可以通过可视化编程工具和模型驱动的开发方法来加速应用程序的开发周期，提高开发效率，并降低开发和维护成本。

## 161、什么是mock数据?

Mock数据是指在前端开发过程中，模拟后端接口返回的数据的一种技术。当后端接口尚未开发完毕或者由于某些原因无法访问时，前端开发人员可以使用Mock数据来测试和开发前端应用程序，以保证前端应用程序的正常运行。 Mock数据通常是由前端开发人员自己编写的，可以使用JavaScript或其他编程语言来生成。Mock数据应该尽可能地模拟真实的后端接口返回的数据，以确保前端应用程序的正确性。Mock数据通常包括JSON格式的数据，模拟后端接口返回的数据结构和内容。 Mock数据的优点包括：

1. 提高开发效率：使用Mock数据可以在后端接口未完成时，快速开发前端应用程序，提高开发效率。
2. 减少沟通成本：使用Mock数据可以减少前后端沟通成本，前端开发人员可以独立地开发和测试应用程序。
3. 提高可靠性：使用Mock数据可以减少后端接口对前端开发的影响，提高前端应用程序的可靠性。
4. 方便测试：使用Mock数据可以方便地进行单元测试和集成测试，提高测试效率。 Mock数据的缺点包括：
5. 数据不真实：使用Mock数据可能会导致前端应用程序的数据不真实，因此必须在后端接口完成后进行替换。
6. 数据结构不确定：使用Mock数据时，前端开发人员需要自己设计数据结构，这可能会导致数据结构不确定或者需要多次修改。 总之，Mock数据是一种在前端开发过程中，模拟后端接口返回数据的技术。它可以提高开发效率、减少沟通成本、提高可靠性和方便测试，但同时也存在数据不真实和数据结构不确定等缺点。