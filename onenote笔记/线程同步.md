---
title: 线程同步:

author: IceStone
created: '2020-04-08T12:28:59.956Z'
tags: java多线程

---

# 线程同步:

* 并发:同一个对象被多个线程同时操作
* 处理多线程问题时,多个线程访问同一个对象,并且某些线程还想修改这个对象,这时候我们就需要线程同步,线程同步其实就是一种等待机制,多个需要同时访问此对象的线程进入这个对象的等待池形成队列,等待在前面线程使用完毕,下一个线程再使用
 
* 队列和锁:
* 线程同步:

    * 由于同一进程的多个线程共享同一块存储空间,在带来方便的同时,也带来了访问冲突的问题,为了保证数据在方法中被访问时的正确性,在访问时加入锁机制synchronized,当一个线程获得对象的排它锁,独占资源,其他线程必须等待,使用后释放锁即可,存在以下问题:
    * 一个线程持有锁会导致其他所有需要此锁的线程被挂起
    * 在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题
    * 如果一个优先级高的线程等待一个优先级低的线程释放锁,会导致优先级倒置,引起性能问题

* 同步方法:

    * 由于我们可以通过private关键字来保证数据对象只能被方法访问,所以我们只需要针对方法提出一套机制,这套机制就是synchronizd关键字,它包括两种用法:synchronized方法和synchronized块

        * 同步方法:public synchronized void method(int args){}

    * synchronized方法控制对"对象"的访问,每个对象对应一把锁,每个synchronized方法都必须获得调用该方法的对象的锁才能执行,否则线程会阻塞,方法一旦执行,就会独占该锁,直到该犯法返回才释放锁,后面被阻塞的线程才能获得这个锁,进行执行

        * 缺陷:若将一个大的方法申明为synchronized将会影响效率

    * 方法里面需要修改的资源才需要锁,锁的太多了,浪费资源

* 同步块:

    * 同步块:synchronized(Obj){}
    * Obj称之为同步监视器

        * Obj可以是任何对象,但是推荐使用共享资源作为同步监视器
        * 同步方法中无需指定同步监视器,因为同步方法的同步监视器就是this,就是这个对象本身,或者是class[反射中讲解]

    * 同步监视器的执行过程:

        * 1.第一个线程访问,锁定同步监视器,执行其中代码
        * 2.第二个线程访问,发现同步监视器被锁定,无法访问
        * 3.第一个线程访问完毕,解锁同步监视器
        * 4第二个线程访问,发现同步监视器没有锁,然后锁定并访问


* 死锁:

    * 多个线程各自占有一些共享资源,并且互相等待其他线程释放占有的资源才能运行,而导致两个或者多个线程都在等待对方释放资源,都停止执行的情形,某一个同步块同时拥有"两个以上对象的锁"时,就可能会发生"死锁"的问题

* 死锁如何避免:

    * 产生死锁避免的四个必要条件:

        * 1.互斥条件:一个资源每次只能被一个进程使用
        * 2.请求与保持条件:一个进程因请求资源而阻塞时,对已获得的资源保持不放
        * 3.不剥夺条件:进程已获得的资源,在未使用完之前,不能前行剥夺
        * 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

    * 上面列出的四个必要条件,我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生
    *  


 
